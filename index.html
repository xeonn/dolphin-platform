<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Dolphin Platform</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Dolphin Platform</h1>
<div class="details">
<span id="revnumber">version 0.9.0-SNAPSHOT</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_architecture_overview">1.1. Architecture overview</a></li>
<li><a href="#_sources">1.2. Sources</a></li>
</ul>
</li>
<li><a href="#_the_remote_presentation_model">2. The Remote Presentation Model</a></li>
<li><a href="#_dolphin_platform_jumpstart">3. Dolphin Platform Jumpstart</a>
<ul class="sectlevel2">
<li><a href="#_creating_a_project_with_maven">3.1. Creating a project with Maven</a></li>
<li><a href="#_creating_a_project_with_lazybones">3.2. Creating a project with Lazybones</a></li>
<li><a href="#_creating_a_project_by_hand">3.3. Creating a project by hand</a>
<ul class="sectlevel3">
<li><a href="#_dolphin_platform_on_the_server">3.3.1. Dolphin Platform on the server</a></li>
<li><a href="#_dolphin_platform_on_the_client">3.3.2. Dolphin Platform on the client</a>
<ul class="sectlevel4">
<li><a href="#_java_based_clients">Java based clients</a></li>
<li><a href="#_javascript_based_clients">JavaScript based clients</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_javadoc">4. JavaDoc</a></li>
<li><a href="#_the_dolphin_platform_lifecycle">5. The Dolphin Platform Lifecycle</a>
<ul class="sectlevel2">
<li><a href="#_the_lifecycle_for_one_client">5.1. The Lifecycle for one client</a></li>
<li><a href="#_creating_a_javafx_clients_that_supports_the_dolphin_platform_lifecycle">5.2. Creating a JavaFX clients that supports the Dolphin Platform Lifecycle</a></li>
<li><a href="#_the_dolphin_platform_lifecycle_on_the_server">5.3. The Dolphin Platform Lifecycle on the server</a></li>
</ul>
</li>
<li><a href="#_the_model_api">6. The Model API</a>
<ul class="sectlevel2">
<li><a href="#_creating_a_bean">6.1. Creating a bean</a></li>
<li><a href="#supported-types">6.2. Supported types</a>
<ul class="sectlevel3">
<li><a href="#_custom_data_types">6.2.1. Custom data types</a></li>
</ul>
</li>
<li><a href="#_using_collections">6.3. Using collections</a></li>
<li><a href="#bean-hierarchies">6.4. Defining hierarchies</a></li>
<li><a href="#_add_observer">6.5. Add observer</a></li>
<li><a href="#_defining_the_model_of_a_mvc_group">6.6. Defining the model of a MVC group</a></li>
<li><a href="#bean-manager">6.7. Working with the BeanManager</a>
<ul class="sectlevel3">
<li><a href="#_creating_new_model_instances">6.7.1. Creating new model instances</a></li>
<li><a href="#_removing_a_bean">6.7.2. Removing a bean</a></li>
</ul>
</li>
<li><a href="#_the_dolphin_platform_garbage_collection">6.8. The Dolphin Platform garbage collection</a></li>
<li><a href="#_how_to_work_with_the_model_api">6.9. How to work with the Model API</a></li>
<li><a href="#_property_binding">6.10. Property Binding</a></li>
</ul>
</li>
<li><a href="#_controller_api">7. Controller API</a>
<ul class="sectlevel2">
<li><a href="#_defining_a_controller">7.1. Defining a controller</a></li>
<li><a href="#_defining_the_model">7.2. Defining the model</a></li>
<li><a href="#_controller_actions">7.3. Controller actions</a></li>
<li><a href="#_benefits_of_managed_controllers">7.4. Benefits of managed controllers</a></li>
<li><a href="#_definition_of_the_client_scope">7.5. Definition of the client scope</a></li>
<li><a href="#_injection_of_dolphin_platform_specific_services">7.6. Injection of Dolphin Platform specific services</a>
<ul class="sectlevel3">
<li><a href="#_the_bean_manager">7.6.1. The bean manager</a></li>
<li><a href="#_the_event_bus">7.6.2. The event bus</a></li>
<li><a href="#_the_dolphin_platform_session">7.6.3. The Dolphin Platform session</a></li>
<li><a href="#_the_property_binder">7.6.4. The property binder</a></li>
</ul>
</li>
<li><a href="#_react_on_events_on_the_server">7.7. React on events on the server</a></li>
</ul>
</li>
<li><a href="#_the_event_bus_2">8. The Event Bus</a>
<ul class="sectlevel2">
<li><a href="#_general_overview_of_the_event_bus">8.1. General overview of the event bus</a></li>
<li><a href="#_defining_a_topic">8.2. Defining a topic</a></li>
<li><a href="#_sending_an_event">8.3. Sending an event</a></li>
<li><a href="#_receiving_events">8.4. Receiving events</a></li>
<li><a href="#_use_cases_for_the_event_bus">8.5. Use-cases for the event bus</a></li>
</ul>
</li>
<li><a href="#_javaee_integration">9. JavaEE Integration</a>
<ul class="sectlevel2">
<li><a href="#_configuration_of_the_application">9.1. Configuration of the application</a></li>
<li><a href="#_next_steps">9.2. Next steps</a></li>
<li><a href="#_using_the_jumpstart">9.3. Using the jumpstart</a></li>
</ul>
</li>
<li><a href="#_spring_integration">10. Spring Integration</a>
<ul class="sectlevel2">
<li><a href="#_defining_the_main_class_of_the_application">10.1. Defining the main class of the application</a></li>
<li><a href="#_configuration_of_the_application_2">10.2. Configuration of the application</a></li>
<li><a href="#_next_steps_2">10.3. Next steps</a></li>
<li><a href="#_using_the_jumpstart_2">10.4. Using the jumpstart</a></li>
</ul>
</li>
<li><a href="#server-configuration">11. Server configuration</a>
<ul class="sectlevel2">
<li><a href="#_supported_properties">11.1. Supported properties</a></li>
</ul>
</li>
<li><a href="#_javafx_client_api">12. JavaFX client API</a></li>
<li><a href="#_security">13. Security</a>
<ul class="sectlevel2">
<li><a href="#_provide_security_in_a_java_based_client">13.1. Provide Security in a Java based client</a></li>
<li><a href="#_provide_security_in_a_javascript_based_client">13.2. Provide Security in a JavaScript based client</a></li>
</ul>
</li>
<li><a href="#_validation_support">14. Validation Support</a>
<ul class="sectlevel2">
<li><a href="#_using_validation_constraints">14.1. Using validation constraints</a></li>
<li><a href="#_validate_a_model">14.2. Validate a model</a></li>
</ul>
</li>
<li><a href="#_changelog">15. Changelog</a>
<ul class="sectlevel2">
<li><a href="#_version_0_8_10">15.1. Version 0.8.10</a></li>
<li><a href="#_version_0_8_9">15.2. Version 0.8.9</a></li>
<li><a href="#_version_0_8_8">15.3. Version 0.8.8</a></li>
<li><a href="#_version_0_8_7">15.4. Version 0.8.7</a></li>
<li><a href="#_version_0_8_6">15.5. Version 0.8.6</a></li>
<li><a href="#_version_0_8_5">15.6. Version 0.8.5</a></li>
<li><a href="#_version_0_8_4">15.7. Version 0.8.4</a></li>
<li><a href="#_version_0_8_3">15.8. Version 0.8.3</a></li>
<li><a href="#_version_0_8_2">15.9. Version 0.8.2</a></li>
<li><a href="#_version_0_8_1">15.10. Version 0.8.1</a></li>
<li><a href="#_version_0_8_0">15.11. Version 0.8.0</a></li>
</ul>
</li>
<li><a href="#_dolphin_platform_release_documentation">16. Dolphin Platform release documentation</a>
<ul class="sectlevel2">
<li><a href="#_dolphin_platform_repositories">16.1. Dolphin Platform repositories</a></li>
<li><a href="#_dolphin_platform_repositories_walkthrough">16.2. Dolphin Platform repositories walkthrough</a>
<ul class="sectlevel3">
<li><a href="#_install_needed_tools_for_the_release">16.2.1. Install needed tools for the release</a></li>
<li><a href="#_realising_the_javascript_repositories">16.2.2. Realising the JavaScript repositories</a></li>
<li><a href="#_realising_the_java_repository">16.2.3. Realising the Java repository</a></li>
<li><a href="#_realising_the_android_repository">16.2.4. Realising the Android repository</a></li>
<li><a href="#_realising_the_jumpstart_repository">16.2.5. Realising the jumpstart repository</a></li>
<li><a href="#_general_release_steps">16.2.6. General release steps</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Dolphin Platform is a framework that implements the remote presentation model pattern and provides a modern way to create enterprise applications. As you might know there are several of these frameworks out there. So let us start by describing what makes the Dolphin Platform special and why we decided to create it.</p>
</div>
<div class="sect2">
<h3 id="_architecture_overview"><a class="anchor" href="#_architecture_overview"></a>1.1. Architecture overview</h3>
<div class="paragraph">
<p>In the Dolphin Platform, all models will automatically be synchronized between client and server. Thus, you don&#8217;t need to think about any specific endpoints or requests.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/model-sync.png" alt="model sync">
</div>
<div class="title">Figure 1. Synchronization of the model</div>
</div>
<div class="paragraph">
<p>Based on this, the Dolphin Platform defines server side controllers that contain all the controller logic for a specific view. The lifecycle of these controllers is automatically synchronized with the view lifecycle. With this approach you have a MVC group for each client view with a synchronized model and a managed controller.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/getting-started-1.png" alt="getting started 1">
</div>
<div class="title">Figure 2. Different clients</div>
</div>
<div class="paragraph">
<p>The Dolphin Platform provides a server and client framework that let you easily write applications based on the described pattern. To do so the platform contains support for well known sever framework like JavaEE or Spring and several implementations to create clients by using for example JavaFX or Polymer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sources"><a class="anchor" href="#_sources"></a>1.2. Sources</h3>
<div class="paragraph">
<p>The Dolphin Platform provides implementations fo several platforms. Therefore the APIs
and implementations of the Dolphin Platform can be found in several GitHub repositories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Java based server API and the basic client API can be found in the main repository
of the Dolphin Platform. This repository contains the JavaFX client API, this documentation
and some samples, too. The repository can be find <a href="https://github.com/canoo/dolphin-platform">here</a>.</p>
</li>
<li>
<p>The Android client API can be found in a <a href="https://github.com/canoo/dolphin-platform-android">separate repository</a>.</p>
</li>
<li>
<p>For JavaScript the Dolphin Platform provides a basic framework independend implementation
that can be found <a href="https://github.com/canoo/dolphin-platform-js">here</a>.</p>
</li>
<li>
<p>For Google Polymer the Dolphin Platform provides a client API that is based on the
basic JavaScript cient API. The Polymer client API can be found
<a href="https://github.com/canoo/dolphin-platform-polymer">in this repository</a>.</p>
</li>
<li>
<p>The Dolphin Platform provides a Maven archetype to create the initial structure of
a Dolphin Platform based project. The sources of the archetype can be found
<a href="https://github.com/canoo/dolphin-platform-spring-boot-archetype">here</a>.</p>
</li>
<li>
<p>The Dolphin Platform provides a Lazybones template to create the initial structure of
a Dolphin Platform based project. The sources of the template can be found
<a href="https://github.com/canoo/dolphin-platform-lazybones-templates">here</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_remote_presentation_model"><a class="anchor" href="#_the_remote_presentation_model"></a>2. The Remote Presentation Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Remote Presentation Model (RPM) is a software design pattern for implementing user interfaces. Like Model View
Controller (MVC) it divides a module into three parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Model</p>
</li>
<li>
<p>View</p>
</li>
<li>
<p>Controller</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The main difference to MVC is that the Controller part of the RPM pattern is speretated from the view. In a client server
architecture the controller part is mostly defined on the server. By doing so several benefits of server site programming
can be directly used in the controller. In addition the view part is mostly extreme lightweight and can easily be
replaced. Both controller and view know the model and can interact with the model. Since the components RPM pattern can
be seperated on client and server the model must be synchronized between client and server.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/rpm1.png" alt="rpm1">
</div>
<div class="title">Figure 3. Remote Presentation Model</div>
</div>
<div class="paragraph">
<p>Since view and controller can interact with the model it&#8217;s a best practice to support the observer pattern for the model.
By doing so the view can simply bind its components to properties of the model and the server can react on changes by
simply adding a lister to an observable property.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/workflow.png" alt="workflow">
</div>
<div class="title">Figure 4. Basic RPM workflow</div>
</div>
<div class="paragraph">
<p>The Dolphin Platform provides an implementation of the Remote Presentation Model pattern. This documentation provides
descriptions and samples of the public model, controller and view APIs of the Dolphin Platform.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dolphin_platform_jumpstart"><a class="anchor" href="#_dolphin_platform_jumpstart"></a>3. Dolphin Platform Jumpstart</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To get started with Dolphin Platform and create your first client-server-project several Maven archetypes are provided
by Dolphin Platform. Based on this archetypes it&#8217;s quite easy to create a full functional client-server-application as a
perfect base for your own project or to learn the different APIs of Dolphin Platform by simply experimenting with the
generated project.</p>
</div>
<div class="sect2">
<h3 id="_creating_a_project_with_maven"><a class="anchor" href="#_creating_a_project_with_maven"></a>3.1. Creating a project with Maven</h3>
<div class="paragraph">
<p>To create a new project only Maven must be installed on your system. Once Maven is installed you can create a complete
project with only one shell command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">$ mvn archetype:generate -Dfilter=com.canoo.dolphin-platform:</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The archetypes are deployed to (<a href="http://search.maven.org">Maven Central</a>) and
(<a href="https://bintray.com/bintray/jcenter">JCenter</a>). If you have configured your Maven installation to use a different
repository that do not mirror Maven Central or JCenter your Maven installation might not find the archetypes to generate
a jumpstart.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The command will start a Maven process that creates the new project. To do so you can choose between different options
in a shell wizard:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jumpstart.png" alt="jumpstart">
</div>
<div class="title">Figure 5. The shell wizard</div>
</div>
<div class="paragraph">
<p>As a first step you need to choose on what archetype your project should depend. Dolphin Platform provides several
archetypes to create for example projects that use Spring Boot or JavaEE on the server. After you have defined the
archetype you need to select a version of the archetype. This version is related to the Dolphin Platform version the
archetype depends on. Here it&#8217;s best practice to simply select the last version. As a last step you need to specify
<code>groupId</code>, <code>artifactId</code> and the <code>version</code> of your new project. Once this is done the generation might tackle some time
on the first call since all needed dependencies and plugins are downloaded to your computer. You can simply import the
generated project in any IDE of your choice that supports Maven projects. The generated project contains a readme.md
file that describes how the client and server parts of the project can be started.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_project_with_lazybones"><a class="anchor" href="#_creating_a_project_with_lazybones"></a>3.2. Creating a project with Lazybones</h3>
<div class="paragraph">
<p>Next to the Maven archetype we provide a <a href="https://github.com/pledbrook/lazybones">Lazybones</a> template for application that
are based on the Dolphin Platform. The project and a getting-started
documentation <a href="https://github.com/canoo/dolphin-platform-lazybones-templates">can be found at github</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_project_by_hand"><a class="anchor" href="#_creating_a_project_by_hand"></a>3.3. Creating a project by hand</h3>
<div class="paragraph">
<p>Maybe some developers don&#8217;t want to use the Maven archetype to create a new Dolphin Platform based application or want to
integrate the Dolphin Platform in an existing application. Even if the Maven archetype is the fasted way to set up a
startable project it&#8217;s quite easy to create such an application from scratch.</p>
</div>
<div class="paragraph">
<p>The API and implementation of the Dolphin Platform is splitted in several modules. Depending on the application
infrastructure a developer needs to add different modules to the application dependencies. The following diagramm
gives an overview of all Dolphin Platform modules:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/modules.png" alt="modules">
</div>
<div class="title">Figure 6. Dolphin Platform modules</div>
</div>
<div class="sect3">
<h4 id="_dolphin_platform_on_the_server"><a class="anchor" href="#_dolphin_platform_on_the_server"></a>3.3.1. Dolphin Platform on the server</h4>
<div class="paragraph">
<p>On the server side you can choose between a JavaEE or a Spring integration. Each of this
modules depends on the basic server module of the Dolphin Platform that contains the public
API for the server part. Based on this you only need to add one dependency to your server
application. All modules on the server are full compatible to Java 7 and above.</p>
</div>
<div class="paragraph">
<p>You can simply integrate Dolphin Platform in a Spring based application. To do so you only need to add the Spring
module. All Java modules of the Dolphin Platform are available at Maven Central and JCenter. The following snippet
shows the spring module as a Maven dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>com.canoo.dolphin-platform<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dolphin-platform-server-spring<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>0.8.9<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next to this the Dolphin Platform provides support for JavaEE. The following snippet shows the JavaEE module of the
Dolphin Platform as a Maven dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>com.canoo.dolphin-platform<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dolphin-platform-server-javaee<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>0.8.9<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Additional information can be found in the JavaEE and Spring chapter of this documentation.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_dolphin_platform_on_the_client"><a class="anchor" href="#_dolphin_platform_on_the_client"></a>3.3.2. Dolphin Platform on the client</h4>
<div class="paragraph">
<p>Since all Dolphin Platform modules on the server a written in Java the client modules are written in multiple programming
languages to support as many platforms as possible. Currently you can choose between a Java implementation for Desktop
and mobile clients (JavaFX and Android) and a JavaScript implementation with special API for several JavaScript frameworks
(currently Polymer and AngularJS).</p>
</div>
<div class="sect4">
<h5 id="_java_based_clients"><a class="anchor" href="#_java_based_clients"></a>Java based clients</h5>
<div class="paragraph">
<p>For a desktop or Android client a developer only need to add the specific Java modules
of the Dolphin Platform as dependencies to the client project.</p>
</div>
<div class="paragraph">
<p>The following snippet shows the dependency for a JavaFX based client as a Maven dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>com.canoo.dolphin-platform<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dolphin-platform-client-javafx<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>0.8.9<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to create a Android application you need to add the follwoing dependency to your
application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>com.canoo.dolphin-platform<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dolphin-platform-client-android<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>0.8.9<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_javascript_based_clients"><a class="anchor" href="#_javascript_based_clients"></a>JavaScript based clients</h5>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_javadoc"><a class="anchor" href="#_javadoc"></a>4. JavaDoc</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Dolphin Platform is based on some modules. The following diagram shows the modules
of the Dolphin Platform and the dependecies between the modules:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/deps.png" alt="deps">
</div>
<div class="title">Figure 7. Module dependencies of the Dolphin Platform</div>
</div>
<div class="paragraph">
<p>The JavaDoc for the modules can be found here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="javadoc/core/">Core API</a></p>
</li>
<li>
<p><a href="javadoc/client/">Client API</a></p>
</li>
<li>
<p><a href="javadoc/client-jfx/">JavaFX API</a></p>
</li>
<li>
<p><a href="javadoc/server/">Server API</a></p>
</li>
<li>
<p><a href="javadoc/server-spring/">Spring API</a></p>
</li>
<li>
<p><a href="javadoc/server-jee/">JavaEE API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_dolphin_platform_lifecycle"><a class="anchor" href="#_the_dolphin_platform_lifecycle"></a>5. The Dolphin Platform Lifecycle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Dolphin Platform provides lifecycles that defines the communication between client and server and the internal
lifecycle of a MVC group.</p>
</div>
<div class="sect2">
<h3 id="_the_lifecycle_for_one_client"><a class="anchor" href="#_the_lifecycle_for_one_client"></a>5.1. The Lifecycle for one client</h3>
<div class="paragraph">
<p>Each clients that is connected to the Dolphin Platform server has its own lifecycle. This lifecycle starts with the
inital connection and will end when the client disconnects from the server. The Dolphin Platform provides several classes in its public
API that wrap the lifecycle and make it quite easy to create an application that is based on the Dolphin
Platform.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_javafx_clients_that_supports_the_dolphin_platform_lifecycle"><a class="anchor" href="#_creating_a_javafx_clients_that_supports_the_dolphin_platform_lifecycle"></a>5.2. Creating a JavaFX clients that supports the Dolphin Platform Lifecycle</h3>
<div class="paragraph">
<p>The <code>dolphin-platform-client-javafx</code> module provides the abstract <code>DolphinPlatformApplication</code> class that can easily be used
to create a JavaFX based client for the Dolphin Platform. Internally the class already defines the Dolphin Platform
lifecycle and by extending the class for a custom client a developer only needs to define some general information.
 The following code shows how a basic implementation might look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyCustomClient</span> <span class="directive">extends</span> DolphinPlatformApplication { <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">URL</span> getServerEndpoint() {
        <span class="keyword">try</span> {
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">URL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080/dolphin</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="2"></i><b>(2)</b>
        } <span class="keyword">catch</span> (<span class="exception">MalformedURLException</span> e) {
             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Can not create URL!</span><span class="delimiter">&quot;</span></span>, e);
        }
    }

     <span class="annotation">@Override</span>
     <span class="directive">protected</span> <span class="type">void</span> start(Stage s, ClientContext c) <span class="directive">throws</span> <span class="exception">Exception</span> { <i class="conum" data-value="3"></i><b>(3)</b>
         s.setScene(<span class="keyword">new</span> Scene(<span class="keyword">new</span> <span class="predefined-type">Label</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello Dolphin</span><span class="delimiter">&quot;</span></span>)));
         s.show();
     }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Our custom client extends the abstract <code>DolphinPlatformApplication</code> class</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We need to implement the abstract method by providing the server endpoint of the Dolphin Platform. This is <code>/dolphin</code>
by default but can be configured on the server</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Like the void <code>start(Stage primaryStage)</code> method of the JavaFX <code>Application</code> class this method will automatically be
called once JavaFX is ready. In additon this method provides the Dolphin Platform <code>ClientContext</code> as an parameter. By
doing so you already have a connection to the Dolphin Platform server once this method is called. The method is called on
the JavaFX Platform thread.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The given example already creates a connection to the Dolphin Platform server and shows an UI once the connection is
established and JavaFX is ready. In addition this client already provides a disconnect once the UI will be closed by a
user and some raw error handling. All this is defined in the <code>DolphinPlatformApplication</code> class but can simply be overwritten.
If you want more control of the error handling you can simply provide a custom implementation for the methods
<code>void onInitializationError(Stage primaryStage, ClientInitializationException initializationException)</code> and
<code>void onShutdownError(ClientShutdownException shutdownException)</code>. A client that defines
specific functionallity for all this states of the lifecycle might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyCustomClient</span> <span class="directive">extends</span> DolphinPlatformApplication {

    <span class="directive">private</span> <span class="predefined-type">Logger</span> LOG = LoggerFactory.getLogger(MyCustomClient.class);

    <span class="directive">protected</span> <span class="predefined-type">URL</span> getServerEndpoint() {
        <span class="keyword">try</span> {
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">URL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080/dolphin</span><span class="delimiter">&quot;</span></span>);
        } <span class="keyword">catch</span> (<span class="exception">MalformedURLException</span> e) {
             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Can not create URL!</span><span class="delimiter">&quot;</span></span>, e);
        }
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> start(Stage s, ClientContext c) <span class="directive">throws</span> <span class="exception">Exception</span> {
        LOG.info(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform Lifecycle init successful</span><span class="delimiter">&quot;</span></span>);
        s.setScene(<span class="keyword">new</span> Scene(<span class="keyword">new</span> <span class="predefined-type">Label</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello Dolphin</span><span class="delimiter">&quot;</span></span>)));
        s.show();
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> onInitializationError(Stage s, ClientInitializationException e) {
        LOG.error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform Lifecycle error on init</span><span class="delimiter">&quot;</span></span>, e);
        <span class="local-variable">super</span>.onInitializationError(s, e);
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> onShutdownError(ClientShutdownException e) {
        LOG.error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform Lifecycle error on shutdown</span><span class="delimiter">&quot;</span></span>, e);
        <span class="local-variable">super</span>.onShutdownError(e);
    }


     <span class="annotation">@Override</span>
     <span class="directive">protected</span> <span class="type">void</span> onShutdown() {
         LOG.info(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform Lifecycle shutdown successful</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="5"></i><b>(5)</b>
         <span class="local-variable">super</span>.onShutdown();
     }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In this custom implementation a logger should be used to log information of the lifecycle</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Once the start method is called the Dolphin Platform initialization has been done and the client is connected to the server</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If an exception occurs on the initialization this method will be called. You should call the super method in a custom
implementation since a clear shutdown is already defined in the <code>DolphinPlatformApplication</code> class.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If an exception occurs on the shutdown this method will be called. You should call the super method in a custom
implementation since a clear shutdown is already defined in the <code>DolphinPlatformApplication</code> class.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Once the start method is called the Dolphin Platform shutdown has been done and the client can be destroyed. You
should call the super method in a custom implementation since a clear shutdown is already defined in the
<code>DolphinPlatformApplication</code> class.
Note: <code>onShutdown()</code> is not supported anymore in 0.8.8.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To be true these are not the only moments in that the Dolphin Platform can throw an exception. Maybe the server shuts
down when a client is still connected to the server. In this case the <code>DolphinPlatformApplication</code> class
provides an additional method that can be overridden to handle this kind of remoting exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyCustomClient</span> <span class="directive">extends</span> DolphinPlatformApplication {

    <span class="directive">private</span> Log LOG = LoggerFactory.getLogger(MyCustomClient.class);

    <span class="directive">protected</span> <span class="predefined-type">URL</span> getServerEndpoint() {
        <span class="keyword">try</span> {
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">URL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080/dolphin</span><span class="delimiter">&quot;</span></span>);
        } <span class="keyword">catch</span> (<span class="exception">MalformedURLException</span> e) {
             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">RuntimeException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Can not create URL!</span><span class="delimiter">&quot;</span></span>, e);
        }
    }

     <span class="annotation">@Override</span>
     <span class="directive">protected</span> <span class="type">void</span> start(Stage s, ClientContext c) <span class="directive">throws</span> <span class="exception">Exception</span> {
         LOG.info(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform Lifecycle init successful</span><span class="delimiter">&quot;</span></span>);
         s.setScene(<span class="keyword">new</span> Scene(<span class="keyword">new</span> <span class="predefined-type">Label</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello Dolphin</span><span class="delimiter">&quot;</span></span>)));
         s.show();
     }

     <span class="annotation">@Override</span>
     <span class="directive">protected</span> <span class="type">void</span> onInitializationError(Stage primaryStage, ClientInitializationException initializationException) {
         LOG.error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform initialization error</span><span class="delimiter">&quot;</span></span>, initializationException); <i class="conum" data-value="1"></i><b>(1)</b>
         <span class="local-variable">super</span>.onInitializationError(primaryStage, initializationException);
     }

     <span class="annotation">@Override</span>
     <span class="directive">protected</span> <span class="type">void</span> onRuntimeError(<span class="directive">final</span> Stage primaryStage, <span class="directive">final</span> DolphinRuntimeException runtimeException) {
         LOG.error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform runtime error in thread </span><span class="delimiter">&quot;</span></span> + runtimeException.getThread().getName(), runtimeException); <i class="conum" data-value="2"></i><b>(2)</b>
         <span class="local-variable">super</span>.onRuntimeError(primaryStage, runtimeException);
     }

     <span class="annotation">@Override</span>
     <span class="directive">protected</span> <span class="type">void</span> onShutdownError(ClientShutdownException shutdownException) {
         LOG.error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dolphin Platform shutdown error</span><span class="delimiter">&quot;</span></span>, shutdownException); <i class="conum" data-value="3"></i><b>(3)</b>
         <span class="local-variable">super</span>.onShutdownError(shutdownException);
     }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This method is called if the connection to the Dolphin Platform server can&#8217;t be created.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This method is called if the connection to the Dolphin Platform server throws an exception at runtime.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This method is called if the connection to the Dolphin Platform server can&#8217;t be closed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You should call the super methods in a custom implementation of the error handlers since a clear shutdown is already defined in the <code>DolphinPlatformApplication</code> class.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_dolphin_platform_lifecycle_on_the_server"><a class="anchor" href="#_the_dolphin_platform_lifecycle_on_the_server"></a>5.3. The Dolphin Platform Lifecycle on the server</h3>
<div class="paragraph">
<p>A Dolphin Platform based server provides a http endpoint that is used for the communication between client and server.
Whenever a new client is created and connects to the server a session is created on the server. The Dolphin Platform
provides its own session type that is called DolphinSession. This session type is "lower than the http session".
The DolphinSession is important if you want to create web application, for example. Since all the tabs of a browser share
the same http session it&#8217;s hard to define data that is only related to one tab in the browser. In that case the lifecycle
of a DolphinSession is bound to a tab in the browser and ends when the tab will be closed.</p>
</div>
<div class="paragraph">
<p>Once a client disconnect its connection to the server the DolphinSession for this client will automatically be removed. If
a client can not disconnect because of an exception or maybe the Java process on the client is killed by an user the
DolphinSession will automatically be removed with the http session on the server.</p>
</div>
<div class="paragraph">
<p>To react on the lifecycle of a client on the server a developer can provide implementations of the <code>DolphinSessionListener</code>
interface that is part of the public server API of the Dolphin Platform. Each implementation of the <code>DolphinSessionListener</code>
interface that is annotated with <code>@DolphinListener</code> will be instantiated at runtime and used as a listener for created and
destroyed session. A basic implementation of such a class might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinListener</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyCustomListener</span> <span class="directive">implements</span> DolphinSessionListener {

    <span class="directive">private</span> <span class="predefined-type">Logger</span> LOG = LoggerFactory.getLogger(MyCustomListener.class);

    <span class="directive">public</span> <span class="type">void</span> sessionCreated(DolphinSession s) {
        LOG.info(<span class="string"><span class="delimiter">&quot;</span><span class="content">Session with id {0} created!</span><span class="delimiter">&quot;</span></span>, s.getId());    <i class="conum" data-value="1"></i><b>(1)</b>
    }

    <span class="directive">public</span> <span class="type">void</span> sessionDestroyed(DolphinSession s) {
        LOG.info(<span class="string"><span class="delimiter">&quot;</span><span class="content">Session with id {0} destroyed!</span><span class="delimiter">&quot;</span></span>, s.getId());  <i class="conum" data-value="2"></i><b>(2)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This method is called for each new DolphinSession that is created on the server</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This method is called for each destroyed DolphinSession on the server</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_model_api"><a class="anchor" href="#_the_model_api"></a>6. The Model API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the core features and maybe the most important concept of Dolphin Platform is the model synchronization between
client and server. For each view in the client a controller instance "lives" in the server that defines all the logic of
the view. A model is automatically shared and synchronized between the client view and the controller on the server.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/model-sync.png" alt="model sync">
</div>
<div class="title">Figure 8. Synchronization of the model</div>
</div>
<div class="paragraph">
<p>Such a model can be a bean or a hierarchy of several beans. Dolphin Platform provides an API to create full observable
beans for the model layer.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The public API of the module layer is defined in the <code>dolphin-platform-core module</code>. The JavaDoc of the module can
be found <a href="javadoc/core/">here</a>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_creating_a_bean"><a class="anchor" href="#_creating_a_bean"></a>6.1. Creating a bean</h3>
<div class="paragraph">
<p>A model for the Dolphin Platform can simply be defined as a Java bean but instead of using primitive date types for all
the attributes of the bean Dolphin Platform provides the <code>Property&lt;V&gt;</code> interface that should be used to define
attributes. Based on this a definition for a bean with only one String attribute will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinBean</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> {

    <span class="directive">private</span> Property&lt;<span class="predefined-type">String</span>&gt; value;

    <span class="directive">public</span> Property&lt;<span class="predefined-type">String</span>&gt; valueProperty() {
        <span class="keyword">return</span> value;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getValue() {
        <span class="keyword">return</span> value.get();
    }

    <span class="directive">public</span> <span class="type">void</span> setValue(<span class="predefined-type">String</span> value) {
           <span class="local-variable">this</span>.value.set(value);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Maybe you ask yourself why the <code>@DolphinBean</code> annotation is needed. Internally the Dolphin Platform checks if a bean
class is annotated with <code>@DolphinBean</code> and will trow a <code>BeanDefinitionException</code> if the annotation is not present. By
doing so it will be easy to check if you use the right model classes. We plan to add some additional features based on
the annotation in the future. One example can be an annotation processor that checks if all classes that are defined as
the Dolphin Platform beans (by adding the <code>@DolphinBean</code> annotation) are valid Dolphin Platform beans.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="supported-types"><a class="anchor" href="#supported-types"></a>6.2. Supported types</h3>
<div class="paragraph">
<p>Currently Dolphin Platform properties and collections support the following types as content:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Integer</code></p>
</li>
<li>
<p><code>Long</code></p>
</li>
<li>
<p><code>Float</code></p>
</li>
<li>
<p><code>Double</code></p>
</li>
<li>
<p><code>Byte</code></p>
</li>
<li>
<p><code>Short</code></p>
</li>
<li>
<p><code>Boolean</code></p>
</li>
<li>
<p><code>String</code></p>
</li>
<li>
<p><code>java.util.Date</code> <em>(since version 0.8.4)</em></p>
</li>
<li>
<p><code>java.util.Calendar</code> <em>(since version 0.8.4)</em></p>
</li>
<li>
<p><code>Enums</code> <em>(since version 0.8.4)</em></p>
</li>
<li>
<p>Dolphin Platform Bean <a href="#bean-hierarchies">(see description)</a></p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
As some browsers have issues with Timezone, one has to use UTC. If the provided Calendar is not set to UTC, it
will be converted.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since version 0.8.8 the Dolphin Platform contains the optional module <code>dolphin-platform-date-time-converter</code> that provides
the support for addition types for properties and collections. All the types are part of the Java 8 date and time API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.time.Duration</code></p>
</li>
<li>
<p><code>java.time.LocalDateTime</code></p>
</li>
<li>
<p><code>java.time.Period</code></p>
</li>
<li>
<p><code>java.time.ZonedDateTime</code></p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Currently the additional data types are only supported in Java. The support for the JavaScript will be added
in a future version
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_custom_data_types"><a class="anchor" href="#_custom_data_types"></a>6.2.1. Custom data types</h4>
<div class="paragraph">
<p>Since version 0.8.8 the Dolphin Platform provides a SPI to add custom data types for properties and collections. To add
support for a new data type a custom converter must be provided. To do so the <code>com.canoo.dolphin.converter.ConverterFactory</code>
interface must be implemented and provided for
<a href="https://docs.oracle.com/javase/tutorial/ext/basics/spi.html">Java Service Provider Interface (SPI)</a>. Examples for custom
data types can be found in the sources of the optional <code>dolphin-platform-date-time-converter</code> module.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_collections"><a class="anchor" href="#_using_collections"></a>6.3. Using collections</h3>
<div class="paragraph">
<p>The first example of a Dolphin Platform bean contained only a String property but most of the time you need more complex
beans. That&#8217;s why we added collection support to the Dolphin Platform model API. Next to the properties a bean can contain
lists that are define by the <code>ObservableList&lt;V&gt;</code> interface. The interface extends the default Java <code>List</code> interface by adding
support for observers. A Dolphin Platform bean that contains a list might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinBean</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> {

    <span class="directive">private</span> ObservableList&lt;<span class="predefined-type">String</span>&gt; values;

    <span class="directive">public</span> ObservableList&lt;<span class="predefined-type">String</span>&gt; getValues() {
        <span class="keyword">return</span> values;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>ObservableList&lt;V&gt;</code> supports <a href="#supported-types">all the same generic types as a property.</a></p>
</div>
</div>
<div class="sect2">
<h3 id="bean-hierarchies"><a class="anchor" href="#bean-hierarchies"></a>6.4. Defining hierarchies</h3>
<div class="paragraph">
<p>A <code>Property&lt;V&gt;</code> or <code>ObservableList&lt;V&gt;</code> instance can not only hold primitive types. As defined in the supported types a property
or list can contain other beans, too. By doing so a model can define a hierarchy of several beans. The following class
shows how a model class that contains a list of other beans might look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinBean</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MainModel</span> {

    <span class="directive">private</span> ObservableList&lt;MyModel&gt; values;

    <span class="directive">public</span> ObservableList&lt;MyModel&gt; getValues() {
        <span class="keyword">return</span> values;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example instances of the <code>MyModel</code> that was shown as an example earlier can be stored in the list of this model
class.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
It&#8217;s important to now that a developer should never create new model instances "by hand". If a model will be
created by simply calling it&#8217;s constructor it won&#8217;t become part of the synchronized models. To create new model
instances the Dolphin Platform bean manager must be used. The API of the bean manager and how it can be used to create
new instances of models and beans <a href="#bean-manager">will be shown later.</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_add_observer"><a class="anchor" href="#_add_observer"></a>6.5. Add observer</h3>
<div class="paragraph">
<p>Both the <code>Property&lt;V&gt;</code> and <code>ObservableList&lt;V&gt;</code> interface implement the observer pattern. By doing so changes in the
model layer can easily be handled in the view and the controller. The interfaces provide methods to add observer that
will be called whenever the internal content will change. The following snippet shows how an observer can be added to
a property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">myModel.valueProperty().onChanged(e -&gt; <span class="predefined-type">System</span>.out.print(<span class="string"><span class="delimiter">&quot;</span><span class="content">Property changed</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the value of the value property will be changed the given observer will be triggered. For properties the observer
is defined by the <code>ValueChangeListener</code> class.
In the given example a lambda expression is used as the observer. So whenever the value will be changed a "Property changed" message will be printed
to the console.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Dolphin Platform modules are compiled against Java 7 but provide a very good support for Java 8 lambda
expressions. Wherever it makes sense interfaces are defined as functional interface. By doing so instances of the
interface can be defined as a lambda expression when using Java 8. In the given example the lambda implements the
<code>ValueChangeListener</code> interface of the Dolphin Platform.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Whenever a <code>ValueChangeListener</code> is called an event object is provided. This object can be used to access the old and
the new value of a change:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">myModel.valueProperty().onChanged(e -&gt; print(<span class="string"><span class="delimiter">&quot;</span><span class="content">Property changed from </span><span class="delimiter">&quot;</span></span> + e.getOldValue() + <span class="string"><span class="delimiter">&quot;</span><span class="content"> to </span><span class="delimiter">&quot;</span></span> + e.getNewValue()));</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>TODO: Subscription</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Subscription subscription = myModel.valueProperty().onChanged(e -&gt; print(<span class="string"><span class="delimiter">&quot;</span><span class="content">Property changed</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_model_of_a_mvc_group"><a class="anchor" href="#_defining_the_model_of_a_mvc_group"></a>6.6. Defining the model of a MVC group</h3>
<div class="paragraph">
<p>As you can see in the following image each MVC group in the Dolphin Platform contains a model. A MVC group is based on the
MVC pattern and contains a controller, a view and a model. In the Dolphin Platform approach the controller lives on the server
and the view is defined on the client. The model is shared between the client and the server.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/model-sync.png" alt="model sync">
</div>
<div class="title">Figure 9. A MVC group</div>
</div>
<div class="paragraph">
<p>As we have seen until now a model is defined by properties and collections. Since <code>Property&lt;V&gt;</code> and <code>ObservableList&lt;V&gt;</code> are
defined as interfaces and no model provides a specific constructor it&#8217;s still not clear how a new instance of a model should
created. Thanks to the Dolphin Platform architecture a developer don&#8217;t need to think about the model instanciation or the
lifecycle of a model. Whenever a new MVC group is created by the platform the model instance will be created automatically.
To do so the model must be defined in the controller. The Dolphin Platform provides the <code>@DolphinModel</code> annotation that is
used to inject the created model instance in the controller instance. The following sample code shows a minimal controller
that defines its model type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@DolphinController
public class MyController {

    @DolphinModel
    private MyModel model;

}</pre>
</div>
</div>
<div class="paragraph">
<p>The model instance will be automatically synchronized with the client. Since the model is completelly observable you can
 simply bind the properties and lists that are defined in the model to your UI components in the client.</p>
</div>
</div>
<div class="sect2">
<h3 id="bean-manager"><a class="anchor" href="#bean-manager"></a>6.7. Working with the BeanManager</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_creating_new_model_instances"><a class="anchor" href="#_creating_new_model_instances"></a>6.7.1. Creating new model instances</h4>
<div class="paragraph">
<p>Since all beans of the Dolphin Platform model layer will be synchronized between client and server a new model instance
can not be created "by hand" (<code>MyBean bean = new MyBean</code>). So instead of creating a new bean instance by calling its
constructor the BeanManager interface must be used to create a new bean instance. By doing so the bean instance will
automatically be added to the bean manager and synchronized between client and server. Here is an example how a bean
instance can be created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>MyBean bean = beanManager.create(MyBean.class);</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_removing_a_bean"><a class="anchor" href="#_removing_a_bean"></a>6.7.2. Removing a bean</h4>
<div class="paragraph">
<p>The BeanManager interface provides several methods to remove beans. Until a bean is removed by the bean manager it will
be synchronized between client and server. Even if a bean isn&#8217;t referenced in the custom application code anymore it won&#8217;t
be removed by the Java Garbage Collection since it&#8217;s still referenced by the bean manager. The following methods can be
used to remove beans from the client-server-synchronization:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void remove(Object bean)</code></p>
</li>
<li>
<p><code>void removeAll(Class&lt;?&gt; beanClass)</code></p>
</li>
<li>
<p><code>void removeAll(Object&#8230;&#8203; beans)</code></p>
</li>
<li>
<p><code>void removeAll(Collection&lt;?&gt; beans)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these methods do not work transitively. This means that in a hierarchy of beans all beans must be detached from the
bean manager seperately.</p>
</div>
<div class="paragraph">
<p>In addition the BeanManager interface provides a method to check if a bean is still synchronized between client and
server or if it&#8217;s already removed from the bean manager:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boolean isManaged(Object bean)</code></p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Currently all mentioned methods are deprecated. Since the Dolphin Platform provides its own Garbage
Collector beans can be automatically removed by the bean manager once they are not referenced in the model layer anymore.
Until now the Dolphin Platform garbage collection is an experimental feature that must be activated on the server. Once
the garbage collection will become a default in the Dolphin Platform the deprecated methods will be removed in a future
release.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_dolphin_platform_garbage_collection"><a class="anchor" href="#_the_dolphin_platform_garbage_collection"></a>6.8. The Dolphin Platform garbage collection</h3>
<div class="paragraph">
<p>The Dolphin Platform contains a garbage collection on the server that will automatically remove all bean instances from
the remoting layer that aren&#8217;t referenced anymore by other beans. Currently the garbage collection is an experimental
feature and it&#8217;s not active by default. If you want to use the garbage collection you need to add
<code>garbageCollectionActive=true</code> to the <code>dolphin.properties</code> file (see chapter <a href="#server-configuration">Server configuration</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_work_with_the_model_api"><a class="anchor" href="#_how_to_work_with_the_model_api"></a>6.9. How to work with the Model API</h3>
<div class="paragraph">
<p>To get a better overview of the API that helps you to define presentation models in Dolphin Platform we added a small
example.
Let&#8217;s say we have the following view that can be part of a photo library app:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/model-example-1.png" alt="model example 1">
</div>
<div class="title">Figure 10. Example Application</div>
</div>
<div class="paragraph">
<p>In this view, we have several elements that need a data model. If the data of this app is stored on a server the data
model must be shared between the client and the server. When having a look at the screen we can see 3 different elements
that need data from the data model to visualize itself or provide user interaction:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The title of the screen needs a String as its content. We can display the title of a photo album or an internationalized
string.</p>
</li>
<li>
<p>The slider that defines a value. Let&#8217;s imagine that the interaction with the slider changes the size of the pictures in
the main area. Maybe the last value of the slider should be stored on the server to automatically save user preferences</p>
</li>
<li>
<p>All pictures in the main area. As you can see each card in this area contains an image and maybe a badge in the top
right corner. A badge element in the top right corner visualizes if the photo is flagged.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Based on this definition we would create a presentation model that might look like this one:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/model-example-2.png" alt="model example 2">
</div>
<div class="title">Figure 11. The presentation model</div>
</div>
<div class="paragraph">
<p>When defining such a model in JavaFX, you can use the cool property API and the observable collections that are part of
JavaFX. Modern JavaScript frameworks like AngularJS or Polymer provide a similar behavior and therefore we decided to
offer the same benefits when defining models with the Dolphin Platform. In Dolphin Platform you work with properties and
observable collections, too. Therefore it&#8217;s really easy to define a hierarchical model for your view. A model for the
shown view might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinBean</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">PhotoOverviewModel</span> {

  <span class="directive">private</span> Property&lt;<span class="predefined-type">String</span>&gt; title;

  <span class="directive">private</span> Property&lt;<span class="predefined-type">Double</span>&gt; sliderValue;

  <span class="directive">private</span> ObservableList&lt;PhotoModel&gt; photos;

  <span class="comment">//getter &amp; setter</span>

}

<span class="annotation">@DolphinBean</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">PhotoModel</span> {

  <span class="directive">private</span> Property&lt;<span class="predefined-type">String</span>&gt; imageUrl;

  <span class="directive">private</span> Property&lt;<span class="predefined-type">Boolean</span>&gt; flagged;

  <span class="comment">//getter &amp; setter</span>

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All properties and collections in the Dolphin Platform are observable and therefore it&#8217;s quite easy to observe them on
the client and the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">myModel.getTitleProperty().onChange(e -&gt; <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">New title: </span><span class="delimiter">&quot;</span></span> + e.getNewValue()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>For all client APIs we support first class support for the Dolphin Platform properties. When working with JavaFX for
example it&#8217;s quite easy and intuitive to bind a synchronized Dolphin Platform property to a JavaFX property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FXBinder.bind(booleanJavaFXProperty).bidirectionalTo(booleanDolphinProperty);</code></pre>
</div>
</div>
<div class="paragraph">
<p>On JavaScript clients the handling is even more elegant as you can bind the Dolphin Platform model directly in HTML.</p>
</div>
<div class="paragraph">
<p>The main benefit of this concept is that you can use the same model classes on the server and the client. Because the
model will automatically be synchronized between the view and the server controller it feels like you work with the same
instance. By doing so you can simply bind a string property to a textfield in the view and observe it&#8217;s value on the
server. The change events will automatically be fired on the server when you start typing in the textfield.</p>
</div>
</div>
<div class="sect2">
<h3 id="_property_binding"><a class="anchor" href="#_property_binding"></a>6.10. Property Binding</h3>
<div class="paragraph">
<p>The Dolphin Platform provides an easy way to create a bidirectional binding between 2 properties of the same generic type.
Currently the binding API only supports properties that are defined in the same client session. If you want to sync
properties on several clients the event bus is currently the best way to do this.
To create a binding between 2 properties in the same client session you need the <code>PropertyBinder</code> class. An instance of
this class can simply be injected in any controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyController</span> {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> PropertyBinder binder;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All bindings are defined by qualifiers that are represented by the <code>Qualifier</code> class. For a new binding you need to
define a <code>Qualifier</code> instance that defines the generic type of the properties that should be bound. Since you can reuse
the <code>Qualifier</code> instance for all bindings of that type it&#8217;s best practice to create a static instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MyConstants</span> {

    <span class="directive">public</span> <span class="directive">final</span> <span class="directive">static</span> Qualifier&lt;<span class="predefined-type">String</span>&gt; userNameQualifier = Qualifier&lt;<span class="predefined-type">String</span>&gt;.create();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have the <code>PropertyBinder</code> instance and the <code>Qualifier</code> you can start defining bindings. To do so you define the same
qualifier for all properties that should be bound:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">propertyBinder.bind(model.userNameProperty(), MyConstants.userNameQualifier);</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using the same qualifier in several controller classes you can simply bind properties in a client scope without doing
manual updates.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_controller_api"><a class="anchor" href="#_controller_api"></a>7. Controller API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When using Dolphin Platform the frontend of an application is split into several views. For each view instance in the
client a controller instance is managed in the server.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mvc1.png" alt="mvc1">
</div>
<div class="title">Figure 12. Views and Controllers</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The public API of the server layer is defined in the <code>dolphin-platform-server module</code>. The JavaDoc of the module can
be found <a href="javadoc/server/">here</a>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_defining_a_controller"><a class="anchor" href="#_defining_a_controller"></a>7.1. Defining a controller</h3>
<div class="paragraph">
<p>A controller type is defined as a Java class on the server. This is done with the <code>@DolphinController</code> annotation. Each
controller class on the server must be annotated by using this annotation to define the class as a Dolphin Platform controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="comment">//...</span>

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each controller type / class is marked by an unique identifier. If developers don&#8217;t specify an identifier on their own
the full name of the controller class is used. In the given example the controller would have the identifier
<code>com.company.app.controller.MyViewController</code> (if it&#8217;s part of the <code>com.company.app.controller</code> package). In general
it&#8217;s a better to specify an identifier for the controller class since refactoring (like moving the controller class in
a different package) can change its identifier. A custom identifier for a controller can simply be defined by using the
<code>@DolphinController</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">ViewController1</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="comment">//...</span>

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the controller has the unique identifier <code>ViewController1</code>. When defining custom names for the
controllers it&#8217;s important to always specify a controller name that is unique in the whole application. Since the
identifier is used on the client to access a specific controller type it&#8217;s best practice to define the controller names
as constants in a module that is shared between client and server (both depend on the module).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/common.png" alt="common">
</div>
<div class="title">Figure 13. Dependencies of a common module</div>
</div>
<div class="paragraph">
<p>All the constants can easily be specified in an interface, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ControllerConstants</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> CONTROLLER1_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">MyViewController</span><span class="delimiter">&quot;</span></span>;

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> CONTROLLER2_NAME = <span class="string"><span class="delimiter">&quot;</span><span class="content">ViewController2</span><span class="delimiter">&quot;</span></span>;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By doing so the constants can easily be used to specify the identifier of a controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER1_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="comment">//...</span>

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_model"><a class="anchor" href="#_defining_the_model"></a>7.2. Defining the model</h3>
<div class="paragraph">
<p>Since the view and the controller share a model it&#8217;s important that the controller knows about the model. To do so the
model type must be specified in the controller class. Whenever a controller will be created the model will automatically
be injected in the controller. To define the model in the controller Dolphin Platform provides the <code>@DolphinModel</code>
annotation. By using this annotation the related model type can be specified in a controller and simply injected at runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER1_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>How a model can be specified and how it can be used on the client and the server can be found in the documentation of
the model API.</p>
</div>
</div>
<div class="sect2">
<h3 id="_controller_actions"><a class="anchor" href="#_controller_actions"></a>7.3. Controller actions</h3>
<div class="paragraph">
<p>Actions are endpoints of the controller that can be triggered by the view. For example this can happen when a user
clicks a button in the client. This button action will then trigger an action in the server controller instance that
maybe stores some date in the database or refreshes the model.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/action.png" alt="action">
</div>
<div class="title">Figure 14. Calling an action</div>
</div>
<div class="paragraph">
<p>A controller action is defined as a method in the controller that is annotated by <code>@DolphinAction</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER1_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

    <span class="annotation">@DolphinAction</span>
    <span class="directive">public</span> <span class="type">void</span> onAction() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action was triggered!</span><span class="delimiter">&quot;</span></span>);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the action will be triggered by the client it must be specified by an identifier. This identifier must be unique
in the given controller type. By default the name of the method will be used but as described for the <code>@DolphinController</code>
annotation it&#8217;s best practice to specify a custom constant name to avoid refactoring issues:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER1_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

    <span class="annotation">@DolphinAction</span>(ControllerConstants.ACTION1_NAME)
    <span class="directive">public</span> <span class="type">void</span> onAction() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action was triggered!</span><span class="delimiter">&quot;</span></span>);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes it&#8217;s necessary to submit parameters to the server action. Like controllers and actions parameters must be
specified by an identifier. To define the identifier for a parameter of the action Dolphin Platform provides the
<code>@Param</code> annotation that must be added to each parameter of the action method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER1_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

    <span class="annotation">@DolphinAction</span>(ControllerConstants.ACTION1_NAME)
    <span class="directive">public</span> <span class="type">void</span> onAction(<span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> id) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action was triggered for id </span><span class="delimiter">&quot;</span></span> + id);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if in this example only one parameter is defined the Dolphin Platform actions support any count of parameters. Here
it&#8217;s only important that each parameter has a unique identifier in the context of the action and that the parameters are
of a supported type. Currently Dolphin Platform supports the following types for parameters: <code>Integer</code>, <code>Long</code>, <code>Double</code>,
<code>Float</code>, <code>Boolean</code>, <code>String</code>. It&#8217;s best practice to not use primitives here since null values are always supported and
can end in an Exception since Java autoboxing can&#8217;t convert null to a primitive number or boolean. Some additional
common types like <code>Date</code> will be added in future releases.</p>
</div>
</div>
<div class="sect2">
<h3 id="_benefits_of_managed_controllers"><a class="anchor" href="#_benefits_of_managed_controllers"></a>7.4. Benefits of managed controllers</h3>
<div class="paragraph">
<p>Since a controller is always created and managed by the underlying platform (like Spring or JavaEE) a developer doesn&#8217;t
need to care about controller and model creation. The last sample already defines a full useable controller that will
automatically be created (and a new model instance will be injected) whenever the related view is created on the client.
Next to this the controller offers all the benefit that a managed beans offers based on the underlying platform. Based
on this it&#8217;s no problem to use CDI if Dolphin Platform is used in a JavaEE environment. In addition default annotations
like <code>@PostConstruct</code> and <code>@PreDestroy</code> are supported. The following example shows how such a controller could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER1_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> MyService service;

    <span class="annotation">@PostContruct</span>
    <span class="directive">public</span> <span class="type">void</span> init() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="annotation">@PreDestroy</span>
    <span class="directive">public</span> <span class="type">void</span> shutdown() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Bye, bye</span><span class="delimiter">&quot;</span></span>);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s important to know that even if a controller instance is a managed object it can not be injected in any other
managed bean. This belongs on some restrictions in the Dolphin Platform Architecture: Even if the lifecycle of a
controller is well defined it&#8217;s possible to have several instances of the same controller. Let&#8217;s say your front-end
contains a tabbed pane and you have 2 instances of the same view in this pane. By doing so it&#8217;s not possible to specify
what controller instance should be injected in bean. For a future release of Dolphin Platform it&#8217;s planned to define
parent-child-relations between controller instances. Currently the Dolphin Platform event bus should be used for
communication between controllers and / or additional services.</p>
</div>
</div>
<div class="sect2">
<h3 id="_definition_of_the_client_scope"><a class="anchor" href="#_definition_of_the_client_scope"></a>7.5. Definition of the client scope</h3>
<div class="paragraph">
<p>Dolphin Platform provides an additional custom Scope called <code>ClientScope</code>. This scope is currently implemented for
JavaEE and Spring and it&#8217;s defined as a scope that is "lower than the session scope". This scope is important if you
want to create web applications, for example. Since all the tabs of a browser share the same session it&#8217;s hard to define
data that is only related to one tab in the browser. In that case the lifecycle of a client scope is bound to a tab in
the browser and ends when the tab will be closed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/clientscope.png" alt="clientscope">
</div>
<div class="title">Figure 15. Definition of the client scope</div>
</div>
<div class="paragraph">
<p>For both JavaEE and Spring a <code>@ClientScoped</code> annotation is defined that can be used to give any bean the specific scope:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ClientScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyLocalStoreService</span> {

    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; values = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>();

    <span class="directive">public</span> <span class="type">void</span> add(<span class="predefined-type">String</span> val) {
        values.add(val);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The given service can now simply be injected in any controller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER1_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> MyLocalStoreService service;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Internally the client scope is defined by an unique identifier that is shared between client and server with each
request. Based on this the scope only "lives" inside a Dolphin Platform request roundtrip. At the moment this means
that beans that are defined for the client scope can only be injected in Dolphin Platform controller classes or classes
that are (transitive) injected in controllers. For a future release we plan to support general HTTP endpoints that can
be called from a client and "live" in the client scope. This will be useful to provide specific content like images or
files to the client.</p>
</div>
</div>
<div class="sect2">
<h3 id="_injection_of_dolphin_platform_specific_services"><a class="anchor" href="#_injection_of_dolphin_platform_specific_services"></a>7.6. Injection of Dolphin Platform specific services</h3>
<div class="paragraph">
<p>The Dolphin Platform provide several services that can be injected in any managed bean. Since the Dolphin Platform
controllers are managed beans and support dependency injection the Dolphin Platform specific services can be injected in
any controller.</p>
</div>
<div class="sect3">
<h4 id="_the_bean_manager"><a class="anchor" href="#_the_bean_manager"></a>7.6.1. The bean manager</h4>
<div class="paragraph">
<p>The Dolphin Platform bean manager provides methods to manage the model layer. More information about the model layer
and how to use the bean manager can be found in the <strong>Model API</strong> chapter. The bean manager is defined by the
<code>com.canoo.dolphin.BeanManager</code> interface. Instances are managed objects in the client session scope.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> BeanManager beanManager;

     <span class="comment">//...</span>

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_event_bus"><a class="anchor" href="#_the_event_bus"></a>7.6.2. The event bus</h4>
<div class="paragraph">
<p>The Dolphin Platform provides its own event bus that can be used to provide interaction between several sessions or to
access the Dolphin Platform from a background thread or endpoint. The event bus is defined by the
 <code>com.canoo.dolphin.server.event.DolphinEventBus</code> interface. Instances are managed objects in the application scope.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> DolphinEventBus eventBus;

     <span class="comment">//...</span>

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_dolphin_platform_session"><a class="anchor" href="#_the_dolphin_platform_session"></a>7.6.3. The Dolphin Platform session</h4>
<div class="paragraph">
<p>The Dolphin Platform offers a service to interact with the client session. To do so the
<code>com.canoo.dolphin.server.DolphinSession</code> can be injected. The interface provides similar functionallity as the
<code>javax.servlet.http.HttpSession</code> interface does for the http session. Instances are managed objects in the client session
scope.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> DolphinSession session;

     <span class="comment">//...</span>

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_property_binder"><a class="anchor" href="#_the_property_binder"></a>7.6.4. The property binder</h4>
<div class="paragraph">
<p>The Dolphin Platform provides a way to create binding between properties in the model layer. This bindings can be
created by injecting the com.canoo.dolphin.server.binding.PropertyBinder interface. A more detailed description of
bindings can be found in the <strong>Model API</strong> chapter. Instances are managed objects in the client session scope.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> PropertyBinder binder;

     <span class="comment">//...</span>

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_react_on_events_on_the_server"><a class="anchor" href="#_react_on_events_on_the_server"></a>7.7. React on events on the server</h3>
<div class="paragraph">
<p>TODO 2 ways: eventbus or session.runLater&#8230;&#8203;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_event_bus_2"><a class="anchor" href="#_the_event_bus_2"></a>8. The Event Bus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dolphin Platform provides an event bus that can be used to send events to client sessions on the server. By doing so
it&#8217;s quite easy to create dynamic application with the Dolphin Platform that automatically propagate information to
several clients. A good example for such an application is a messaging app in that all messages that are typed by a user
will be directly visible in the client instances of several other users.</p>
</div>
<div class="sect2">
<h3 id="_general_overview_of_the_event_bus"><a class="anchor" href="#_general_overview_of_the_event_bus"></a>8.1. General overview of the event bus</h3>
<div class="paragraph">
<p>The event bus of Dolphin Platform can only be used on the server. It&#8217;s part of the basic server module
(dolphin-platform-server`) and therefore no special dependencies need to be added to a Dolphin Platform application to
use the event bus. The event bus implements the publish-subscribe-pattern and can be used to send events to all
subscribers of a specific topic.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/event-bus1.png" alt="event bus1">
</div>
<div class="title">Figure 16. Overview of the event bus</div>
</div>
<div class="paragraph">
<p>To do so a Dolphin Platform controller (or other beans that live in the Dolphin Platform client scope) can be registered
as subscriber for a specific topic. Any managed bean of an application can send custom events to a defined topic. By
doing so all subscribers will be notified and receive the event. The event can contain custom data which allows a
developer to send informations to several controller instances.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/event-bus2.png" alt="event bus2">
</div>
<div class="title">Figure 17. Overview of the event bus</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_a_topic"><a class="anchor" href="#_defining_a_topic"></a>8.2. Defining a topic</h3>
<div class="paragraph">
<p>As already mentioned the Dolphin Platform event bus is topic based. This means that all event must be published to a
specified topic and all receivers are always subscribed to a topic. In Dolphin Platform the topic is not simply
defined by a String but by the <code>Topic&lt;E&gt;</code> class. By doing so the topic can already define what types of data can be send
to this topic based on the generic identifier. Since topics are used at the publisher and the receiver site it&#8217;s best
practice to define them as constants. Here is an example how topics can be specified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">EventTopics</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> Topic&lt;<span class="predefined-type">String</span>&gt; DESCRIPTION_ADDED_TOPIC = <span class="keyword">new</span> Topic();

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> Topic&lt;MyCustomBean&gt; DATA_CHANGED_TOPIC = <span class="keyword">new</span> Topic();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example only items of type <code>MyCustomBean</code> can be send to the <code>DATA_CHANGED_TOPIC</code> topic. Internally the topic
uses an unique identifier for specification. A developer can define it&#8217;s own identifier by simply passing a <code>String</code> to
the constructor of the <code>Topic</code>. This is useful for debugging since you can see a readable name of the topic but in that
case a developer must check that all topics have unique identifiers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">EventTopics</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> Topic&lt;<span class="predefined-type">String</span>&gt; DESCRIPTION_ADDED_TOPIC = <span class="keyword">new</span> Topic(<span class="string"><span class="delimiter">&quot;</span><span class="content">descriptionAddedTopic</span><span class="delimiter">&quot;</span></span>);

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> Topic&lt;MyCustomBean&gt; DATA_CHANGED_TOPIC = <span class="keyword">new</span> Topic(<span class="string"><span class="delimiter">&quot;</span><span class="content">dataChangedTopic</span><span class="delimiter">&quot;</span></span>);

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sending_an_event"><a class="anchor" href="#_sending_an_event"></a>8.3. Sending an event</h3>
<div class="paragraph">
<p>The Dolphin Platform provides an injectable <code>DolphinEventBus</code> bean that must be used to send an event to a topic. By
doing so each bean that is managed by the underlying container (like Spring or JavaEE) can publish events. To publish an
event you always need to define the topic to that the event should be published. In addition data can be sent as part of
the event message. Publishing an event is a non-blocking operation. Here is an example how a event can be sent to a
specific topic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ApplicationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyLocalStoreService</span> {

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> DolphinEventBus eventBus;

    <span class="directive">public</span> <span class="type">void</span> addDescription(<span class="predefined-type">String</span> desc) {
        eventBus.publish(EventTopics.DESCRIPTION_ADDED_TOPIC, desc);
    }

    <span class="directive">public</span> <span class="type">void</span> updateData(MyCustomBean data) {
        eventBus.publish(EventTopics.DATA_CHANGED_TOPIC, data);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the previously created topics are used. As you can see data of the type that is defined in the generic
identifier of the <code>Topic&lt;E&gt;</code> instances is sent to the topic. Sending another type of data (an instance of a different
class) will end in a compiler exception.</p>
</div>
</div>
<div class="sect2">
<h3 id="_receiving_events"><a class="anchor" href="#_receiving_events"></a>8.4. Receiving events</h3>
<div class="paragraph">
<p>To receive events of a specific topic the receiver must subscribe itself to the topic. This is done by adding a message
listener to the topic. This listener will be called whenever a new event was published for the given topic. Since the
event handling is always done in a Dolphin Platform communication roundtrip an event receiver must be a Dolphin Platform
controller or a managed bean that is defined by the client scope. The following controller class shows how a subscription
can be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> DolphinEventBus eventBus;

    <span class="annotation">@PostContruct</span>
    <span class="directive">public</span> <span class="type">void</span> init() {
        eventBus.subscribe(EventTopics.DATA_CHANGED_TOPIC, e -&gt; {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Data changed: </span><span class="delimiter">&quot;</span></span> e.getData().getName();
        });

        eventBus.subscribe(EventTopics.DESCRIPTION_ADDED_TOPIC, e -&gt; {
                model.getDescriptions().add(e.getData());
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see the listener can simply access the data that was sent to the topic by using <code>event.getData()</code>. Thanks to
the typesafety of the event bus the data doesn' t need to be casted to the needed type. In the example you can see one big
benefit of the event bus: Since all Dolphin Platform model instances will automatically be shared and synchronized between
client and server the changes of the model that are done in the subscription of the <code>DESCRIPTION_ADDED_TOPIC</code> topic will
automatically be snychronized with the client and can trigger an update of the UI. By doing so it&#8217;s quite easy to update
several clients dynamically based on events.</p>
</div>
<div class="paragraph">
<p>The <code>DolphinEventBus</code> doesn&#8217;t provide a method to unregister subscriptions. Instead of this the <code>subscribe(&#8230;&#8203;)</code> methods
return an object of type <code>Subscription</code>. This object can easily be used to unsubscribe from a topic. By doing so the
following code defines a controller that can be dynamically subscribed and unsubscribed from a topic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.CONTROLLER_NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyViewController</span> {

    <span class="annotation">@DolphinModel</span>
    <span class="directive">private</span> MyModel model;

    <span class="annotation">@Inject</span>
    <span class="directive">private</span> DolphinEventBus eventBus;

    <span class="directive">private</span> Subscription subscription;

    <span class="annotation">@DolphinAction</span>
    <span class="directive">public</span> <span class="type">void</span> activateLiveUpdates() {
        <span class="keyword">if</span>(subscription != <span class="predefined-constant">null</span>) {
            subscription = eventBus.subscribe(EventTopics.DESCRIPTION_ADDED_TOPIC, e -&gt; {
                    model.getDescriptions().add(e.getData());
            });
        }
    }

    <span class="annotation">@DolphinAction</span>
    <span class="directive">public</span> <span class="type">void</span> deactivateLiveUpdates() {
        <span class="keyword">if</span>(subscription != <span class="predefined-constant">null</span>) {
            subscription.unsubscribe();
            subscription = <span class="predefined-constant">null</span>;
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_use_cases_for_the_event_bus"><a class="anchor" href="#_use_cases_for_the_event_bus"></a>8.5. Use-cases for the event bus</h3>
<div class="paragraph">
<p>There are several use cases and scenarios that can simply be developed by using the Open Dolphin event bus.
TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_javaee_integration"><a class="anchor" href="#_javaee_integration"></a>9. JavaEE Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even if mostly all of the public server APIs of the Dolphin Platform don&#8217;t depend on the underlying container
implementation a special dependency must be added to a project that is created as a JavaEE based application.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/javaee-dependency.png" alt="javaee dependency">
</div>
<div class="title">Figure 18. Dependencies for a JavaEE based server</div>
</div>
<div class="paragraph">
<p>The <code>dolphin-platform-server-javaee</code> dependency adds the Dolphin Platform server API and JavaEE APIs as transitive
dependencies. For a maven based project a minimum  <code>pom.xml</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;project</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;modelVersion&gt;</span>4.0.0<span class="tag">&lt;/modelVersion&gt;</span>

    <span class="tag">&lt;groupId&gt;</span>com.canoo.sample<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>server<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/version&gt;</span>

    <span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>com.canoo.dolphin-platform<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>dolphin-platform-server-javaee<span class="tag">&lt;/artifactId&gt;</span>
            <span class="tag">&lt;version&gt;</span>{dolphin-platform-version}<span class="tag">&lt;/version&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
    <span class="tag">&lt;/dependencies&gt;</span>

<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In most cases you will define the model classes in a separate module that is shared between client and server and server
must be added as a second dependency to your application.
Once you start the server application the Dolphin Platform bootstrap will automatically be initialized.</p>
</div>
<div class="sect2">
<h3 id="_configuration_of_the_application"><a class="anchor" href="#_configuration_of_the_application"></a>9.1. Configuration of the application</h3>
<div class="paragraph">
<p>The Dolphin Platform part of the application can be configured a <code>dolphin.properties</code> file. This file is not JavaEE
specific and therefore it&#8217;s described in the general server part.</p>
</div>
</div>
<div class="sect2">
<h3 id="_next_steps"><a class="anchor" href="#_next_steps"></a>9.2. Next steps</h3>
<div class="paragraph">
<p>When developing a Dolphin Platform application with JavaEE you can use all the benefits of both worlds. This means that
you can simply define CDI beans and inject them in Dolphin Platform controllers. A general overview of the Dolphin
Platform server API can be found here.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_jumpstart"><a class="anchor" href="#_using_the_jumpstart"></a>9.3. Using the jumpstart</h3>
<div class="paragraph">
<p>Dolphin Platform provides several Maven archetypes to quickly create a full client server application. By doing so you
only need an installed Maven on your system and can run the following command on a shell:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn archetype:generate -Dfilter=com.canoo.dolphin-platform:</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will start a Maven build that creates a full client-server Maven project for you. A full documentation of the
jumpstart can be found here.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spring_integration"><a class="anchor" href="#_spring_integration"></a>10. Spring Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even if mostly all of the public server APIs of the Dolphin Platform don&#8217;t depend on the underlying container
implementation a special dependency must be added to a project that is created as a Spring (Boot) application.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-dependency.png" alt="spring dependency">
</div>
<div class="title">Figure 19. Dependencies for a Spring based server</div>
</div>
<div class="paragraph">
<p>The <code>dolphin-platform-server-spring</code> dependency adds the Dolphin Platform server API and Spring as transitive
dependencies. For a maven based project a minimum  <code>pom.xml</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;project</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;modelVersion&gt;</span>4.0.0<span class="tag">&lt;/modelVersion&gt;</span>

    <span class="tag">&lt;groupId&gt;</span>com.canoo.sample<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>server<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/version&gt;</span>

    <span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>com.canoo.dolphin-platform<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>dolphin-platform-server-spring<span class="tag">&lt;/artifactId&gt;</span>
            <span class="tag">&lt;version&gt;</span>{dolphin-platform-version}<span class="tag">&lt;/version&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
    <span class="tag">&lt;/dependencies&gt;</span>

<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In most cases you will define the model classes in a separate module that is shared between client and server and server
must be added as a second dependency to your application.</p>
</div>
<div class="sect2">
<h3 id="_defining_the_main_class_of_the_application"><a class="anchor" href="#_defining_the_main_class_of_the_application"></a>10.1. Defining the main class of the application</h3>
<div class="paragraph">
<p>To start your Spring Boot based server a class with a main method need be be defined. In the main method Spring must be
started. In addition the Dolphin Platform bootstrap must be configured and initalialized. To do so Dolphin Platform
provides the <code>@DolphinPlatformApplication</code> annotation that must be added to the main class to automatically load all
needed configurations and trigger the Dolphin Platform Bootstrap. Based on the annotation a main class will always looks
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinPlatformApplication</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServerMain</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span>... args) {
        SpringApplication.run(ServerMain.class, args);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_of_the_application_2"><a class="anchor" href="#_configuration_of_the_application_2"></a>10.2. Configuration of the application</h3>
<div class="paragraph">
<p>The server application can be configured by using all the possibilities that Spring offers for configuration. In
addition a <code>dolphin.properties</code> file can be used to define a configuration for the Dolphin Platform part of the server.
This file is not Spring specific and therefore it&#8217;s described in the general server part.</p>
</div>
</div>
<div class="sect2">
<h3 id="_next_steps_2"><a class="anchor" href="#_next_steps_2"></a>10.3. Next steps</h3>
<div class="paragraph">
<p>When developing a Dolphin Platform application with Spring you can use all the benefits of both worlds. This means that
you can simply define Spring components and service and inject them in Dolphin Platform controllers. A general overview
of the Dolphin Platform server API can be found here.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_jumpstart_2"><a class="anchor" href="#_using_the_jumpstart_2"></a>10.4. Using the jumpstart</h3>
<div class="paragraph">
<p>Dolphin Platform provides several Maven archetypes to quickly create a full client server application. By doing so you
only need an installed Maven on your system and can run the following command on a shell:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="shell">mvn archetype:generate -Dfilter=com.canoo.dolphin-platform:</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will start a Maven build that creates a full client-server Maven project for you. A full documentation of the
jumpstart can be found here.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="server-configuration"><a class="anchor" href="#server-configuration"></a>11. Server configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Dolphin Platform can simply be configured by a property file. To configure the server part of the Dolphin Platform
a <code>dolphin.properties</code>-file must be created in the <code>META-INF</code> folder. In a Maven based project the file would be defined
as <code>project/src/main/resources/META-INF/dolphin.properties</code>. This file must be defined as a regular Java property file.
Here is an example how such a file might look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="txt">openDolphinLogLevel=OFF
useCrossSiteOriginFilter=true</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_supported_properties"><a class="anchor" href="#_supported_properties"></a>11.1. Supported properties</h3>
<div class="paragraph">
<p>Currently the following properties are supported by the Dolphin Platform:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Table title</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Supported values</th>
<th class="tableblock halign-left valign-top">Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">openDolphinLogLevel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the logging level for the remoting layer.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">off, severe, warning, info, config, fine, finer, finest, all</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">severe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useCrossSiteOriginFilter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean property that defines if the HTTP filter for the cross site origin policy should be used. By default the filter
will be used.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true, false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">useSessionInvalidationServlet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean property that defines if the servlet for session validation should be used. By default the servlet will not be used. We plan to remove the servlet completelly in a future release and this property is just for a fallback if not using the servelt will end in issues.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true, false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">servletMapping</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A string based property that defines the server URL endpoint for the Dolphin Platform.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any String that defines an URL mapping</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/dolphin</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sessionTimeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A int that defines the http session timeout in seconds</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any integer value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">900</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">idFilterUrlMappings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list that contains all endpoint that will be filtered by the id filter. This means that all requests for this
endpoints must provide a client id in its header (Header name = dolphin_platform_intern_dolphinClientId).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a comma seperated list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/dolphin</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maxClientsPerSession</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines how many clients can exist in a http session. By using the client scope you can have several clients that share
a session but don&#8217;t use the same data (by using the client scope / dolphin session). By doing so several tabs in a
browser can handle its own clients</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any positive integer value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rootPackageForClasspathScan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the root package that should be used to scan the classpath for Dolphin Platform controllers. By default all
classes in the classpath will be scanned but this might take some time in big projects. By defining a root package all
classes that are located in this package or any subpackage of the root package will be scanned.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a String that matches the java package structure like "com.canoo" or a empty string if the complete classpath should be
scanned.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NULL (scan complete classpath)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mBeanRegistration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines if the Dolphin Platform will register custom MBeans to provide information about the platform and the sessions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true, false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">garbageCollectionActive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By activating the garbage collection the Dolphin Platform checks internally if Dolphin beans are referenced (for example
in a Dolphin Bean hierarchy). If not this beans will automatically be removed on the server and the client. This is an
unstable feature at the moment and should only be activated for tests.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true, false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maxPollTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the timeout of the Dolphin Platform polling mechanism that is used for the event bus and for the session.runLater
call.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_javafx_client_api"><a class="anchor" href="#_javafx_client_api"></a>12. JavaFX client API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When creating a JavaFX client you will normally use FXML to create your view. Next to the FXML file you will have a view
controller to bind all the properties of the view and attach action handlers.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/javafx-1.png" alt="javafx 1">
</div>
<div class="title">Figure 20. Usage of FXML</div>
</div>
<div class="paragraph">
<p>When talking about the Dolphin Platform, this view controller is the perfect point to bind the view to the synchronized
model and the server side controller. Therefore we call this class the "Binder". There are several ways how you can
define such a binding but the most easy one is to extend the <code>AbstractViewBinder</code> class that is part of the Dolphin Platform
JavaFX library. This class already implements the complete lifecycle of the view and you can simply bind the
synchronized presentation model to your view properties. Here is a small example for a view that contains only one
textfield and a button:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyBinder</span> <span class="directive">extends</span> AbstractViewBinder&lt;MyModel&gt; {

  <span class="annotation">@FXML</span>
  <span class="directive">private</span> <span class="predefined-type">Button</span> button;

  <span class="annotation">@FXML</span>
  <span class="directive">private</span> <span class="predefined-type">TextField</span> textfield;

  <span class="directive">public</span> MyBinder(ClientContext clientContext) {
    <span class="local-variable">super</span>(clientContext, ControllerConstants.NAME);
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> init() {
    FXBinder.bind(textfield.textProperty()).bidirectionalTo(getModel().nameProperty());
    button.setOnAction(e -&gt; invoke(ControllerConstants.SAVE));
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> Node getRootNode() {
    <span class="keyword">return</span> <span class="predefined-constant">null</span>;
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the view binder is instantiated, the server controller and the model will automatically be created on the server.
Since the model will be synchronized all the time between client and server you don&#8217;t need to create it on the client.
After this initialization is done the init() method of the binder will be called. With this we bind the name property
that is part of the synchronized model to the text property of the textfield. In addition, we define an action handler
for the button. When the button is pressed an action in the server side controller should be called. To do so the
abstract binder provides the invoke(String name) method that triggers actions on the server controller. In this specific
case the server controller might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinController</span>(ControllerConstants.NAME)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Controller</span> {

  <span class="annotation">@Inject</span>
  <span class="directive">private</span> PersistenceService persistence;

  <span class="annotation">@DolphinModel</span>
  <span class="directive">private</span> MyModel model;

  <span class="annotation">@DolphinAction</span>(ControllerConstants.SAVE)
  <span class="directive">public</span> <span class="type">void</span> save() {
    persistence.insert(model.getName());
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see we never send any data to the server. Since the model will be automatically synchronized, we can directly
store the name string in the model to the database. The Dolphin Platform guarantees that the model will be the same as
it&#8217;s on the client when pressing the button.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/javafx-2.png" alt="javafx 2">
</div>
<div class="title">Figure 21. MVC and Sync</div>
</div>
<div class="paragraph">
<p>Another nice benefit that you might notice is that even if we have communication between the server and the client we
don&#8217;t need to handle several threads. The Dolphin Platform handles all the concurrency and handles all actions in the
right thread. Therefore, the binding between JavaFX properties and Dolphin properties will automatically be handled on
the JavaFX application thread.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_security"><a class="anchor" href="#_security"></a>13. Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Dolphin Platform do not provide its own security concept but can easily be
combined with any security framework. To do so the client API of the Dolphin
Platform provides access to the http connection. Based on this it&#8217;s quite easy
to enrich the http requests of the Dolphin Platform with additional information
like a JWT token.</p>
</div>
<div class="sect2">
<h3 id="_provide_security_in_a_java_based_client"><a class="anchor" href="#_provide_security_in_a_java_based_client"></a>13.1. Provide Security in a Java based client</h3>
<div class="paragraph">
<p>When using a Java client API of the Dolphin Platform (like JavaFX or Android)
the configuration provides the functionality to define a custom http connection
factory and a http response handler. Based on this a developer can implement any
custom security mechanism for the Dolphin Platform.</p>
</div>
<div class="paragraph">
<p>All http connections that will be used by the Dolphin Platform are created by
the <code>HttpURLConnectionFactory</code> instance that is provided by the client configuration.
A developer can easily provide a custom implementation of the <code>HttpURLConnectionFactory</code>
interface and add this to the client configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpURLConnectionFactory myFactory = url -&gt; {
    <span class="predefined-type">HttpURLConnection</span> connection = (<span class="predefined-type">HttpURLConnection</span>) url.connect();
    connection.setRequestProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">Security-Header</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">My secret token</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> connection;
}

ClientConfiguration configuration = <span class="keyword">new</span> JavaFXConfiguration(serverEndpoint);
configuration.setConnectionFactory(myFactory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next to this a response handler can be implemented to extract needed information of
the server response. A custom response handler will be called after the Dolphin
Platform client API has handled the response. To provide such a handler a
developer need to provide a custom implementation of the
<code>HttpURLConnectionResponseHandler</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpURLConnectionResponseHandler myhandler = response -&gt; {
    <span class="predefined-type">String</span> mySecurityToken = response.getHeaderField(<span class="string"><span class="delimiter">&quot;</span><span class="content">Security-Header</span><span class="delimiter">&quot;</span></span>);
    MySecurityManager.setToken(mySecurityToken);
}

ClientConfiguration configuration = <span class="keyword">new</span> JavaFXConfiguration(serverEndpoint);
configuration.setResponseHandler(myhandler);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next to this the Dolphin Platform internally uses a cookie store to handle the
session cookie of the current client session. If a developer needs a specific
cookie store or wants to add some custom cookies to the http requests of the
Dolphin Platform the cookie store that will be used by the Dolphin Platform
client can be defined by the client configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>CookieStore mySpecialCookieStore = MySecurityManager.getCookieStore();

ClientConfiguration configuration = new JavaFXConfiguration(serverEndpoint);
configuration.setCookieStore(mySpecialCookieStore);</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Dolphin Platform offers its own implementations of the interfaces
and configurations that are described in this chapter. The <code>ClientConfiguration</code> class
already provides them as a default configuration. For more information a developer can
have a look at <code>DefaultHttpURLConnectionFactory</code> and <code>DefaultHttpURLConnectionResponseHandler</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_provide_security_in_a_javascript_based_client"><a class="anchor" href="#_provide_security_in_a_javascript_based_client"></a>13.2. Provide Security in a JavaScript based client</h3>
<div class="paragraph">
<p>Todo</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_validation_support"><a class="anchor" href="#_validation_support"></a>14. Validation Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Dolphin Platform provides the optional <code>dolphin-platform-bean-validation</code> module that adds Java Bean Validation
(JSR 303) support to the model layer of the Dolphin Platform. To use the validation support the module must be added as
a dependency to your project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>com.canoo.dolphin-platform<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dolphin-platform-bean-validation<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>{dolphin-platform-version}<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have defined a common module that contains the model descriptions and is shared between client and server you can
simply replace the <code>dolphin-platform-core</code> dependency with <code>dolphin-platform-bean-validation</code> since the validation module
adds a transitive dependency to the core module.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/validation-dependency.png" alt="validation dependency">
</div>
<div class="title">Figure 22. Dependencies for the validation module</div>
</div>
<div class="paragraph">
<p>The <code>dolphin-platform-bean-validation</code> module don&#8217;t depend on a JSR-303 implementation. If your application server don&#8217;t
provide an implementation you need to add for example Hibernate Validation as a dependency. Here is an example for Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.hibernate<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>hibernate-validator<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>5.1.3.Final<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.glassfish<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>javax.el<span class="tag">&lt;/artifactId&gt;</span>
    <span class="tag">&lt;version&gt;</span>3.0.0<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you depend on JavaEE your application container will automatically provide an implementation for you. In that case you
don&#8217;t need to add a specific implementation as a dependency.</p>
</div>
<div class="sect2">
<h3 id="_using_validation_constraints"><a class="anchor" href="#_using_validation_constraints"></a>14.1. Using validation constraints</h3>
<div class="paragraph">
<p>Once the module is added as a dependency the contrains annotations of JSR-303 can be used in Dolphin Platform models.
To do so the <code>Property</code> fields of a model bean must be annotated with the contrains annotations. Here is an example that
defines a "not null" constrain for a <code>String</code> property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@DolphinBean</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> {

    <span class="annotation">@NotNull</span>
    <span class="directive">private</span> Property&lt;<span class="predefined-type">String</span>&gt; value;

    <span class="directive">public</span> Property&lt;<span class="predefined-type">String</span>&gt; valueProperty() {
        <span class="keyword">return</span> value1;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A general description of the Dolphin Platform model API can be found here.</p>
</div>
</div>
<div class="sect2">
<h3 id="_validate_a_model"><a class="anchor" href="#_validate_a_model"></a>14.2. Validate a model</h3>
<div class="paragraph">
<p>By using a validator you can now easily validate instances of the model as described in the bean validation documentation
or several tutorials. Here is a basic code snippet that creates a validator by hand and validates a Dolphin Platform model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Configuration</span>&lt;?&gt; validationConf = Validation.byDefaultProvider().configure();

<span class="predefined-type">Validator</span> validator = validationConf.buildValidatorFactory().getValidator();

<span class="predefined-type">Set</span>&lt;ConstraintViolation&lt;TestBean&gt;&gt; violations = validator.validate(dolphinModel);
<span class="keyword">if</span>(!violations.isEmpty()) {
    <span class="comment">//Handle violations</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some platforms provide injection of a <code>Validator</code> instance. In that case you don&#8217;t need to create a configuration and
validator by hand.
Unresolved directive in index.adoc - include::build.adoc[]</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_changelog"><a class="anchor" href="#_changelog"></a>15. Changelog</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following overview contains all changes of the Dolphin Platform since version 0.8.0.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Until version 1.0.0 we will not mark breaking changes in the public API seperately since the API might still change. To
be true most of the public API of the Dolphin Platform is stable since 0.8.5 and the most changes are related to changing
package structure or adding additional methods to public interfaces. In addition it will be best practice to not use any
method of the API is annotated by <code>@Deprecated</code> since we plan to remove all this methods and classes for the final 1.0.0 release.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_version_0_8_10"><a class="anchor" href="#_version_0_8_10"></a>15.1. Version 0.8.10</h3>
<div class="paragraph">
<p><em>Release date: Jan 12, 2017</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide a first implementation of an Android client API</p>
</li>
<li>
<p>The http connection of the Java client can be accessed and customized to provide custom security or
authentification mechanisms.</p>
</li>
<li>
<p>Dependency to Apache HttpClient library is removed. Java basic HttpUrlConnection is used now.</p>
</li>
<li>
<p>Removed some unneeded dependencies</p>
</li>
<li>
<p>All classes of the Dolphin Platform are refactored to Java. The Dolphin Platform do not provide any
Groovy based implementations any more. (<a href="https://github.com/canoo/dolphin-platform/issues/237">issue</a>, <a href="https://github.com/canoo/dolphin-platform/issues/238">issue</a>)</p>
</li>
<li>
<p>Groovy was removed as dependency (for runtime). Currently only the unit tests of the remoting modules still
depend on Groovy. (<a href="https://github.com/canoo/dolphin-platform/issues/237">issue</a>, <a href="https://github.com/canoo/dolphin-platform/issues/238">issue</a>)</p>
</li>
<li>
<p>Several sources of the remoting layer are refactored and unused functionality was removed. (<a href="https://github.com/canoo/dolphin-platform/issues/237">issue</a>, <a href="https://github.com/canoo/dolphin-platform/issues/238">issue</a>)</p>
</li>
<li>
<p>GSON is used as JSON parser for the remoting layer (<a href="https://github.com/canoo/dolphin-platform/issues/175">issue</a>)</p>
</li>
<li>
<p>The Dolphin Platform provides Docker based integration tests. Currently the integration tests will be executed
against server applications that run in Payara, TomEE and Wildfly. (<a href="https://github.com/canoo/dolphin-platform/issues/248">issue</a>)</p>
</li>
<li>
<p>The Dolphin Platform publish reports to sonar. An overview of the current state of the Dolphin Platform can be
found <a href="https://sonarqube.com/dashboard/index?id=com.canoo.dolphin-platform%3Adolphin-platform">here</a> (<a href="https://github.com/canoo/dolphin-platform/issues/38">issue</a>)</p>
</li>
<li>
<p>JavaDocs hosted at GitHub pages. (<a href="https://github.com/canoo/dolphin-platform/issues/234">issue</a>)</p>
</li>
<li>
<p>Some issues and code smells that were reported by sonar are refactored. (<a href="https://github.com/canoo/dolphin-platform/issues/38">issue</a>)</p>
</li>
<li>
<p>Garbage Collection is activated by default (<a href="https://github.com/canoo/dolphin-platform/issues/261">issue</a>)</p>
</li>
<li>
<p>Garbage Collection will be automatically called by every long poll (<a href="https://github.com/canoo/dolphin-platform/issues/261">issue</a>)</p>
</li>
<li>
<p>Sonar reports for all projects (<a href="https://github.com/canoo/dolphin-platform/issues/313">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_9"><a class="anchor" href="#_version_0_8_9"></a>15.2. Version 0.8.9</h3>
<div class="paragraph">
<p><em>Release date: Dec 16, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide functionality to step into the DP lifecycle on the server (<a href="https://github.com/canoo/dolphin-platform/issues/267">issue</a>)</p>
</li>
<li>
<p>Dependency to GParse is completely removed (<a href="https://github.com/canoo/dolphin-platform/issues/252">issue</a>)</p>
</li>
<li>
<p>Refactoring of the event bus implementation (<a href="https://github.com/canoo/dolphin-platform/issues/127">issue</a>)</p>
</li>
<li>
<p>Event bus can be used in controller tests for Spring (<a href="https://github.com/canoo/dolphin-platform/issues/196">issue</a>)</p>
</li>
<li>
<p>Unneeded javax.inject dependency has been removed (<a href="https://github.com/canoo/dolphin-platform/issues/170">issue</a>)</p>
</li>
<li>
<p>Provide additional information for wrong usage of scopes in Spring (<a href="https://github.com/canoo/dolphin-platform/issues/277">issue</a>)</p>
</li>
<li>
<p>Several Groovy classes are refactored to Java (<a href="https://github.com/canoo/dolphin-platform/pull/270">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_8"><a class="anchor" href="#_version_0_8_8"></a>15.3. Version 0.8.8</h3>
<div class="paragraph">
<p><em>Release date: Nov 14, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Optional module that adds support for new Java 8 Data &amp; Time API in the model layer (<a href="https://github.com/canoo/dolphin-platform/issues/258">issue</a>)</p>
</li>
<li>
<p>Better lifecylce definition in the client API (<a href="https://github.com/canoo/dolphin-platform/pull/255">issue</a>)</p>
</li>
<li>
<p>Bugfix for missing exception handling on the client (<a href="https://github.com/canoo/dolphin-platform/issues/229">issue</a>)</p>
</li>
<li>
<p>Groovy sources compiles with right Java version (<a href="https://github.com/canoo/dolphin-platform/issues/256">issue</a>)</p>
</li>
<li>
<p>Dependency to GParse removed in client and common API (<a href="https://github.com/canoo/dolphin-platform/pull/253">issue</a>)</p>
</li>
<li>
<p>Most parts of the Groovy based client API are refactored to Java (<a href="https://github.com/canoo/dolphin-platform/pull/264">issue</a>)</p>
</li>
<li>
<p>Client API use URL to define connection string (<a href="https://github.com/canoo/dolphin-platform/issues/18">issue</a>)</p>
</li>
<li>
<p>SPI to support custom data types in the model (<a href="https://github.com/canoo/dolphin-platform/pull/263">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_7"><a class="anchor" href="#_version_0_8_7"></a>15.4. Version 0.8.7</h3>
<div class="paragraph">
<p><em>Release date: Aug 24, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Root package for controller scan can be configured (<a href="https://github.com/canoo/dolphin-platform/issues/208">issue</a>)</p>
</li>
<li>
<p>Dolphin beans must be annotated with @DolphinBean (<a href="https://github.com/canoo/dolphin-platform/issues/218">issue</a>)</p>
</li>
<li>
<p>Better exception handling for the garbage collection (<a href="https://github.com/canoo/dolphin-platform/issues/209">issue</a>)</p>
</li>
<li>
<p>Refactoring of Groovy code to Java (<a href="https://github.com/canoo/dolphin-platform/issues/158">issue</a>)</p>
</li>
<li>
<p>Update of all external dependecies to latest version (<a href="https://github.com/canoo/dolphin-platform/issues/139">issue</a>)</p>
</li>
<li>
<p>Usage of MBeans can be configured (<a href="https://github.com/canoo/dolphin-platform/pull/220">issue</a>)</p>
</li>
<li>
<p>Documenation is published to GitHub pages (<a href="https://github.com/canoo/dolphin-platform/issues/226">issue</a>)</p>
</li>
<li>
<p>Binding support for properties (<a href="https://github.com/canoo/dolphin-platform/pull/205">issue</a>)</p>
</li>
<li>
<p>Session timeout can be specified in JBoss application server (<a href="https://github.com/canoo/dolphin-platform/issues/212">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_6"><a class="anchor" href="#_version_0_8_6"></a>15.5. Version 0.8.6</h3>
<div class="paragraph">
<p><em>Release date: Jul 7, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>ClientScope to support multiple browser tabs (<a href="https://github.com/canoo/dolphin-platform/issues/50">issue</a>)</p>
</li>
<li>
<p>Http client can be configured in the client API (<a href="https://github.com/canoo/dolphin-platform/pull/199">issue</a>)</p>
</li>
<li>
<p>Initialization in client API is async (<a href="https://github.com/canoo/dolphin-platform/issues/47">issue</a>)</p>
</li>
<li>
<p>Support for controller tests in Spring (<a href="https://github.com/canoo/dolphin-platform/pull/178">issue</a>)</p>
</li>
<li>
<p>Support for session timeout (<a href="https://github.com/canoo/dolphin-platform/issues/163">issue</a>)</p>
</li>
<li>
<p>Introduction of an optional module that provides reactive approaches for the model layer (<a href="https://github.com/canoo/dolphin-platform/pull/176issue" class="bare">https://github.com/canoo/dolphin-platform/pull/176issue</a>])</p>
</li>
<li>
<p>Bugfix for model garbage collection (<a href="https://github.com/canoo/dolphin-platform/issues/183">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_5"><a class="anchor" href="#_version_0_8_5"></a>15.6. Version 0.8.5</h3>
<div class="paragraph">
<p><em>Release date: May 20, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build switched to Gradle (<a href="https://github.com/canoo/dolphin-platform/pull/140">issue</a>)</p>
</li>
<li>
<p>Integration of the remoting layer (open dolphin) as direct part of the Dolphin Platform project / repo (<a href="https://github.com/canoo/dolphin-platform/pull/154">issue</a>)</p>
</li>
<li>
<p>Build documentation added (<a href="https://github.com/canoo/dolphin-platform/issues/152">issue</a>)</p>
</li>
<li>
<p>Introduction of the model garbage collection as experimental feature (<a href="https://github.com/canoo/dolphin-platform/pull/63">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_4"><a class="anchor" href="#_version_0_8_4"></a>15.7. Version 0.8.4</h3>
<div class="paragraph">
<p><em>Release date: May 9, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Support for several new data types (like enum &amp; date) in the model layer (<a href="https://github.com/canoo/dolphin-platform/issues/55">issue</a>)</p>
</li>
<li>
<p>Bugfix for the client-server connection (<a href="https://github.com/canoo/dolphin-platform/issues/148">issue</a>)</p>
</li>
<li>
<p>Listener support for the lifecylce of the dolphin session on the server (<a href="https://github.com/canoo/dolphin-platform/issues/93">issue</a>)</p>
</li>
<li>
<p>Memory leak on server removed (<a href="https://github.com/canoo/dolphin-platform/issues/130">issue</a>)</p>
</li>
<li>
<p>Public Interfaces for all functionallity of the API that is needed by application developers (<a href="https://github.com/canoo/dolphin-platform/issues/42">issue</a>)</p>
</li>
<li>
<p>Configuration support for the server (<a href="https://github.com/canoo/dolphin-platform/issues/95">issue</a>)</p>
</li>
<li>
<p>Asiidoc based documentation started (<a href="https://github.com/canoo/dolphin-platform/issues/133">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_3"><a class="anchor" href="#_version_0_8_3"></a>15.8. Version 0.8.3</h3>
<div class="paragraph">
<p><em>Release date: Mar 18, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Introduction of the DolphinSession (<a href="https://github.com/canoo/dolphin-platform/pull/121">issue</a>)</p>
</li>
<li>
<p>Licence header for all sources (<a href="https://github.com/canoo/dolphin-platform/pull/125">issue</a>)</p>
</li>
<li>
<p>Definition of JavaFX basic view class to easily bind the model to the view (<a href="https://github.com/canoo/dolphin-platform/issues/117">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_2"><a class="anchor" href="#_version_0_8_2"></a>15.9. Version 0.8.2</h3>
<div class="paragraph">
<p><em>Release date: Mar 7, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Refactoring of the internal server API (<a href="https://github.com/canoo/dolphin-platform/pull/99">issue</a>)</p>
</li>
<li>
<p>Refactoring of the internal client API (<a href="https://github.com/canoo/dolphin-platform/pull/106">issue</a>)</p>
</li>
<li>
<p>Factory interfaces for the client API (<a href="https://github.com/canoo/dolphin-platform/issues/96">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_1"><a class="anchor" href="#_version_0_8_1"></a>15.10. Version 0.8.1</h3>
<div class="paragraph">
<p><em>Release date: Feb 19, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Support for JBoss application server (<a href="https://github.com/canoo/dolphin-platform/issues/78">issue</a>)</p>
</li>
<li>
<p>Command names in the protocol are shorted (<a href="https://github.com/canoo/dolphin-platform/issues/74">issue</a>)</p>
</li>
<li>
<p>Fix for a bug in the list change event (<a href="https://github.com/canoo/dolphin-platform/pull/100">issue</a>)</p>
</li>
<li>
<p>Example isn&#8217;t deployed to Maven central anymore (<a href="https://github.com/canoo/dolphin-platform/pull/89">issue</a>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_version_0_8_0"><a class="anchor" href="#_version_0_8_0"></a>15.11. Version 0.8.0</h3>
<div class="paragraph">
<p><em>Release date: Feb 4, 2016</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>This was the first public release of the Dolphin Platform</p>
</li>
<li>
<p>Optional module for JSR 303 (Bean Validation) support added (<a href="https://github.com/canoo/dolphin-platform/pull/10">issue</a>)</p>
</li>
<li>
<p>The event bus provides type safe topics (<a href="https://github.com/canoo/dolphin-platform/pull/9">issue</a>)</p>
</li>
<li>
<p>Memory leak for session data after session was destroyed has been fixed (<a href="https://github.com/canoo/dolphin-platform/issues/67">issue</a>)</p>
</li>
<li>
<p>Support for list binding in JavaFX (<a href="https://github.com/canoo/dolphin-platform/pull/11">issue</a>)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dolphin_platform_release_documentation"><a class="anchor" href="#_dolphin_platform_release_documentation"></a>16. Dolphin Platform release documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes how a new release for the Dolphin Platform can be created.</p>
</div>
<div class="sect2">
<h3 id="_dolphin_platform_repositories"><a class="anchor" href="#_dolphin_platform_repositories"></a>16.1. Dolphin Platform repositories</h3>
<div class="paragraph">
<p>The sources of the Dolphin Platform are seperated in several repositories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/canoo/dolphin-platform">GitHub repository of the Java API</a></p>
</li>
<li>
<p><a href="https://github.com/canoo/dolphin-platform-js">GitHub repository of the JavaScript basic client API</a></p>
</li>
<li>
<p><a href="https://github.com/canoo/dolphin-platform-polymer">GitHub repository of the Polymer client API</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition we provide several repositories that contain jumpstarts for the Dolphin Platform. This repositories
should be released with each release of the Dolphin Platform:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/canoo/dolphin-platform-lazybones-templates">Dolphin Platform Lazybones template for a Spring
based jumpstart</a></p>
</li>
<li>
<p><a href="https://github.com/canoo/dolphin-platform-spring-boot-archetype">Dolphin Platform Maven archetype for a Spring
based jumpstart</a></p>
</li>
<li>
<p><a href="https://github.com/canoo/dolphin-platform-kumuluz-archetype">Dolphin Platform Maven archetype for a JavaEE
based jumpstart</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_dolphin_platform_repositories_walkthrough"><a class="anchor" href="#_dolphin_platform_repositories_walkthrough"></a>16.2. Dolphin Platform repositories walkthrough</h3>
<div class="paragraph">
<p>For a release the repositories shoud be released in a defined order to create a accurate release. The following
documentation shows a step by step instruction to release all repositories. In general a release starts by releasing
the sources of the JavaScript API repositores followed by the Java repository. Once this is done the jumpstart related
repositories can be released in any order.</p>
</div>
<div class="sect3">
<h4 id="_install_needed_tools_for_the_release"><a class="anchor" href="#_install_needed_tools_for_the_release"></a>16.2.1. Install needed tools for the release</h4>
<div class="paragraph">
<p>TODO: some tools must be installed on the local machine. Add overview for all tools</p>
</div>
</div>
<div class="sect3">
<h4 id="_realising_the_javascript_repositories"><a class="anchor" href="#_realising_the_javascript_repositories"></a>16.2.2. Realising the JavaScript repositories</h4>
<div class="paragraph">
<p>A developer should always start to release the <strong>JavaScript basic API</strong>. To do so several steps are needed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://github.com/canoo/dolphin-platform-js">JavaScript basic API repository</a> must be check out on the local
machine</p>
</li>
<li>
<p>A release will always be done on the master branch.</p>
</li>
<li>
<p>If a developer has checked out the repository for the first time he needs to call <code>npm install</code> in
the root folder of the repository to install all the npm dependencies</p>
</li>
<li>
<p>If a developer has checked out the repository for the first time he needs to call <code>bower install</code> in
the root folder of the repository to install all the bower dependencies</p>
</li>
<li>
<p>In the root folder of the project the <code>npm update</code> command must be called to update all npm dependencies</p>
</li>
<li>
<p>In the root folder of the project the <code>bower update</code> command must be called to update all bower dependencies</p>
</li>
<li>
<p>As a next step the project must be build by using gulp. To do so call <code>gulp clean verify build</code> in the root
folder of the project</p>
</li>
<li>
<p>If the build executes without any error the new version number for the release must be specified in the following
files: <code>bower.json</code>, <code>package.json</code>, <code>sonar-project.properties</code></p>
</li>
<li>
<p>Once this is done the current state must be tagged in git. The name of the tag must match the version of the new
release like <code>0.8.7</code></p>
</li>
<li>
<p>Once the tag is uploaded to the global repository at GitHub the JavaScript basic API has been released</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a next step the <strong>Poylmer API</strong> can be released. To do so several steps are needed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://github.com/canoo/dolphin-platform-polymer">Polymer API repository</a> must be check out on the local
machine</p>
</li>
<li>
<p>A release will always be done on the master branch.</p>
</li>
<li>
<p>The dependency of the Dolphin Platform JS client must be set to the new version in the <code>bower.json</code> file</p>
</li>
<li>
<p>If a developer has checked out the repository for the first time he needs to call <code>npm install</code> in
the root folder of the repository to install all the npm dependencies</p>
</li>
<li>
<p>If a developer has checked out the repository for the first time he needs to call <code>bower install</code> in
the root folder of the repository to install all the bower dependencies</p>
</li>
<li>
<p>In the root folder of the project the <code>npm update</code> command must be called to update all npm dependencies</p>
</li>
<li>
<p>In the root folder of the project the <code>bower update</code> command must be called to update all bower dependencies</p>
</li>
<li>
<p>The new version number for the release must be specified in the following
files: <code>bower.json</code>, <code>package.json</code> and <code>sonar-project.properties</code></p>
</li>
<li>
<p>As a next step the project must be build by using gulp. To do so call <code>gulp clean verify build</code> in the root
folder of the project.</p>
</li>
<li>
<p>Once this is done the current state must be tagged in git. The name of the tag must match the version of the new
release like <code>0.8.7</code></p>
</li>
<li>
<p>Once the tag is uploaded to the global repository at GitHub the Polymer basic API has been released</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a next step the <strong>AngularJS API</strong> can be released. To do so several steps are needed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://github.com/canoo/dolphin-platform-angularjs">AngularJS API repository</a> must be check out on the local
machine</p>
</li>
<li>
<p>A release will always be done on the master branch.</p>
</li>
<li>
<p>The dependency of the Dolphin Platform JS client must be set to the new version in the <code>bower.json</code> file</p>
</li>
<li>
<p>If a developer has checked out the repository for the first time he needs to call <code>npm install</code> in
the root folder of the repository to install all the npm dependencies</p>
</li>
<li>
<p>If a developer has checked out the repository for the first time he needs to call <code>bower install</code> in
the root folder of the repository to install all the bower dependencies</p>
</li>
<li>
<p>In the root folder of the project the <code>npm update</code> command must be called to update all npm dependencies</p>
</li>
<li>
<p>In the root folder of the project the <code>bower update</code> command must be called to update all bower dependencies</p>
</li>
<li>
<p>The new version number for the release must be specified in the following
files: <code>bower.json</code>, <code>package.json</code> and <code>sonar-project.properties</code></p>
</li>
<li>
<p>As a next step the project must be build by using gulp. To do so call <code>gulp clean verify build</code> in the root
folder of the project.</p>
</li>
<li>
<p>Once this is done the current state must be tagged in git. The name of the tag must match the version of the new
release like <code>0.8.7</code></p>
</li>
<li>
<p>Once the tag is uploaded to the global repository at GitHub the AngularJS basic API has been released</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_realising_the_java_repository"><a class="anchor" href="#_realising_the_java_repository"></a>16.2.3. Realising the Java repository</h4>
<div class="ulist">
<ul>
<li>
<p>update the dependecies of all JavaScript modules in the <code>platform-examples</code> folder to the new version</p>
</li>
<li>
<p>Try all examples</p>
</li>
<li>
<p>Create a new branch <code>release/VERSION</code> where <code>VERSION</code> defines the version that should be released (like <code>release/0.8.7</code>)</p>
</li>
<li>
<p>Check out the created release branch</p>
</li>
<li>
<p>update the version number in the <code>gradle.properties</code> file</p>
</li>
<li>
<p>check the changelog in the documentation if all changes are mentioned</p>
</li>
<li>
<p>Call <code>./gradlew clean build</code> from the project folder to check that the build is working</p>
</li>
<li>
<p>Call <code>./gradlew clean bintrayUpload</code> from the project folder. For step the bintray user name and api token
must be configured in the gradle.properties file (<code>/userHome/.gradle/gradle.properties</code>). Add the properties <code>bintrayUsername</code> and <code>bintrayApiKey</code> to the file.</p>
</li>
<li>
<p>Create a tag from the release branch. The name of the tag must match the version of the new
release like <code>0.8.7</code></p>
</li>
<li>
<p>Upload the tag is to the global repository at GitHub</p>
</li>
<li>
<p>Login to Bintray and publish all artifacts to JCenter and Maven Central</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_realising_the_android_repository"><a class="anchor" href="#_realising_the_android_repository"></a>16.2.4. Realising the Android repository</h4>
<div class="ulist">
<ul>
<li>
<p>Create a new branch <code>release/VERSION</code> where <code>VERSION</code> defines the version that should be released (like <code>release/0.8.7</code>)</p>
</li>
<li>
<p>update the version number of Dolphin Platform in the <code>gradle.properties</code> file</p>
</li>
<li>
<p>Call <code>./gradlew clean build</code> from the project folder to check that the build is working</p>
</li>
<li>
<p>Call <code>./gradlew clean bintrayUpload</code> from the project folder. For step the bintray user name and api token
must be configured in the gradle.properties file (<code>/userHome/.gradle/gradle.properties</code>). Add the properties <code>bintrayUsername</code> and <code>bintrayApiKey</code> to the file.</p>
</li>
<li>
<p>Create a tag from the release branch. The name of the tag must match the version of the new
release like <code>0.8.7</code></p>
</li>
<li>
<p>Upload the tag is to the global repository at GitHub</p>
</li>
<li>
<p>Login to Bintray and publish all artifacts to JCenter and Maven Central</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_realising_the_jumpstart_repository"><a class="anchor" href="#_realising_the_jumpstart_repository"></a>16.2.5. Realising the jumpstart repository</h4>
<div class="ulist">
<ul>
<li>
<p>Change the version number of Dolphin Platform in <code>src/main/resources/archetype-resources/pom.xml</code></p>
</li>
<li>
<p>Change the version number of Dolphin Platform in <code>src/main/resources/archetype-resources/polymer-client/bower.json</code></p>
</li>
<li>
<p>Do <code>mvn clean install</code></p>
</li>
<li>
<p>Create sample project by calling <code>mvn archetype:generate -Dfilter=com.canoo.dolphin-platform:</code></p>
</li>
<li>
<p>Check everything in the sample project</p>
</li>
<li>
<p>Create a new branch <code>release/VERSION</code> where <code>VERSION</code> defines the version that should be released (like <code>release/0.8.7</code>)</p>
</li>
<li>
<p>Update version number in main <code>pom.xml</code></p>
</li>
<li>
<p>Call <code>mvn clean deploy</code> from the project folder. For step the bintray user name and api token
must be configured in the <code>.m2/setting.xml</code> Maven setting file.</p>
</li>
<li>
<p>Create a tag from the release branch. The name of the tag must match the version of the new
release like <code>0.8.7</code></p>
</li>
<li>
<p>Upload the tag is to the global repository at GitHub</p>
</li>
<li>
<p>Login to Bintray and publish all artifacts to JCenter and Maven Central</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_general_release_steps"><a class="anchor" href="#_general_release_steps"></a>16.2.6. General release steps</h4>
<div class="paragraph">
<p>Next to the release of the software the version numbers of the latest stable
should be updated in tutorials and readme.md files of the repos.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.9.0-SNAPSHOT<br>
Last updated 2017-01-13 10:30:35 +00:00
</div>
</div>
</body>
</html>